diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/Kconfig linux-3ds/arch/arm/Kconfig
--- linux-5.4.12/arch/arm/Kconfig	2020-01-14 16:08:40.000000000 -0300
+++ linux-3ds/arch/arm/Kconfig	2020-01-17 09:04:32.933831756 -0300
@@ -674,6 +674,8 @@
 
 source "arch/arm/mach-mxs/Kconfig"
 
+source "arch/arm/mach-nintendo3ds/Kconfig"
+
 source "arch/arm/mach-nomadik/Kconfig"
 
 source "arch/arm/mach-npcm/Kconfig"
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/Makefile linux-3ds/arch/arm/Makefile
--- linux-5.4.12/arch/arm/Makefile	2020-01-14 16:08:40.000000000 -0300
+++ linux-3ds/arch/arm/Makefile	2020-01-17 09:06:33.986070156 -0300
@@ -196,6 +196,7 @@
 machine-$(CONFIG_ARCH_MEDIATEK)		+= mediatek
 machine-$(CONFIG_ARCH_MILBEAUT)		+= milbeaut
 machine-$(CONFIG_ARCH_MXS)		+= mxs
+machine-$(CONFIG_ARCH_NINTENDO3DS)	+= nintendo3ds
 machine-$(CONFIG_ARCH_NOMADIK)		+= nomadik
 machine-$(CONFIG_ARCH_NPCM)		+= npcm
 machine-$(CONFIG_ARCH_NSPIRE)		+= nspire
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/boot/dts/nintendo3ds_ctr.dts linux-3ds/arch/arm/boot/dts/nintendo3ds_ctr.dts
--- linux-5.4.12/arch/arm/boot/dts/nintendo3ds_ctr.dts	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/boot/dts/nintendo3ds_ctr.dts	2020-01-31 12:43:27.014837667 -0300
@@ -0,0 +1,246 @@
+/dts-v1/;
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	model = "Nintendo 3DS (CTR)";
+	compatible = "nintendo3ds,ctr";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&gic>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		enable-method = "nintendo3ds,smp";
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,arm11mpcore";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,arm11mpcore";
+			reg = <1>;
+		};
+	};
+
+	chosen {
+		/* No FB: bootargs = "earlyprintk keep_bootcon fbcon=rotate:1 init=/init"; */
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		bootargs = "nr_cpus=2 keep_bootcon fbcon=rotate:1 root=/dev/ram0 init=init console=tty0";
+
+		display: framebuffer@18000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x18000000 (400*240*3)>;
+			width = <240>;
+			height = <400>;
+			stride = <(240*3)>;
+			format = "r8g8b8";
+		};
+
+		fcram: memory@20000000 {
+			device_type = "memory";
+			reg = <0x20000000 0x08000000>;
+		};
+	};
+
+	soc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		compatible = "simple-bus";
+
+		interrupt-parent = <&gic>;
+
+		simplehid: input@10146000 {
+			compatible = "nintendo3ds,nintendo3ds-input";
+			reg = <0x10146000 0x1000>;
+		};
+
+		backlight: backlight@10202000 {
+			compatible = "nintendo3ds,nintendo3ds-backlight";
+			reg = <0x10202000 0x4000>;
+			mcu = <&mcu>;
+		};
+
+		pxi: pxi@10163000 {
+			compatible = "nintendo3ds,nintendo3ds-pxi";
+			interrupts =
+				<GIC_SPI 0x30 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x32 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x33 IRQ_TYPE_EDGE_RISING>;
+			reg = <0x10163000 0x1000>;
+
+			mmc: mmc {
+				compatible = "nintendo3ds,nintendo3ds-mmc";
+			};
+
+			rng: rng {
+				compatible = "nintendo3ds,nintendo3ds-rng";
+			};
+		};
+
+		i2c1: i2c@10161000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10161000 0x1000>;
+		};
+
+		i2c2: i2c@10144000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10144000 0x1000>;
+
+			mcu: mcu@4a {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				compatible = "nintendo3ds,nintendo3ds-mcu";
+				reg = <0x4A>;
+
+				mcu-hid {
+					interrupt-parent = <&gic>;
+
+					compatible = "nintendo3ds,nintendo3ds-mcuhid";
+					interrupts = <GIC_SPI 0x51 IRQ_TYPE_EDGE_RISING>;
+				};
+
+				charger {
+					compatible = "nintendo3ds,nintendo3ds-charger";
+				};
+
+				reset {
+					compatible = "nintendo3ds,nintendo3ds-reset";
+				};
+
+				leds {
+					compatible = "nintendo3ds,nintendo3ds-leds";
+				};
+
+				rtc {
+					compatible = "nintendo3ds,nintendo3ds-rtc";
+				};
+
+			};
+		};
+
+		i2c3: i2c@10148000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10148000 0x1000>;
+		};
+
+		spi0: spi@10160800 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10160800 0x20>;
+
+			flash: nvram@1 {
+				compatible = "jedec,spi-nor";
+				reg = <1>;
+
+				spi-max-frequency = <256000>;
+			};
+		};
+
+		spi1: spi@10142800 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10142800 0x20>;
+
+			ts: codec@0 {
+				compatible = "nintendo3ds,nintendo3ds-codec";
+				spi-max-frequency = <4000000>;
+				reg = <0>;
+
+				touchscreen-size-x = <4096>;
+				touchscreen-size-y = <4096>;
+				touchscreen-inverted-y;
+				touchscreen-swapped-x-y;
+			};
+		};
+
+		spi2: spi@10143800 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10143800 0x20>;
+		};
+
+		refclk: refclk134mkhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <134000000>;
+			clock-output-names = "nintendo3ds:refclk144khz";
+		};
+
+		timer: twd-timer@17E00600 {
+			compatible = "arm,arm11mp-twd-timer";
+			reg = <0x17E00600 0x20>;
+			interrupts = <GIC_PPI 13 (GIC_CPU_MASK_RAW(0xF) | IRQ_TYPE_EDGE_RISING)>;
+			clocks = <&refclk>;
+		};
+
+		watchdog: twd-watchdog@17E00620 {
+			compatible = "arm,arm11mp-twd-wdt";
+			reg = <0x17E00620 0x20>;
+			interrupts = <GIC_PPI 14 (GIC_CPU_MASK_RAW(0xF) | IRQ_TYPE_EDGE_RISING)>;
+		};
+
+		gic: interrupt-controller@17E01000 {
+			compatible = "arm,arm11mp-gic";
+			#interrupt-cells = <3>;
+			#address-cells = <1>;
+			interrupt-controller;
+			reg = <0x17E01000 0x1000>,
+			      <0x17E00100 0x100>;
+		};
+
+		scu: scu@17E00000 {
+			compatible = "arm,arm11mp-scu";
+			reg = <0x17E00000 0x100>;
+		};
+	};
+
+	amba {
+		compatible = "arm,amba-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		dma@10200000 {
+			compatible = "arm,pl330", "arm,primecell";
+			reg = <0x10200000 0x1000>;
+
+			clocks = <&refclk>;
+			clock-names = "apb_pclk";
+
+			interrupts =
+				<GIC_SPI 0x39 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x3A IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x3B IRQ_TYPE_EDGE_RISING>;
+
+			#dma-cells = <1>;
+			#dma-channels = <8>;
+			#dma-requests = <32>;
+		};
+	};
+
+};
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/configs/nintendo3ds_defconfig linux-3ds/arch/arm/configs/nintendo3ds_defconfig
--- linux-5.4.12/arch/arm/configs/nintendo3ds_defconfig	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/configs/nintendo3ds_defconfig	2020-02-21 10:45:49.854855378 -0300
@@ -0,0 +1,2598 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 5.4.12 Kernel Configuration
+#
+
+#
+# Compiler: arm-linux-gnueabihf-gcc (GCC) 9.2.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=90200
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_CC_HAS_WARN_MAYBE_UNINITIALIZED=y
+CONFIG_CC_DISABLE_WARN_MAYBE_UNINITIALIZED=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+# CONFIG_HEADER_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="nintendo3ds"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_USELIB=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+# end of Timers subsystem
+
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_COUNT=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# end of RCU Subsystem
+
+# CONFIG_IKCONFIG is not set
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+# end of Scheduler features
+
+CONFIG_CGROUPS=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+# CONFIG_MEMCG_SWAP_ENABLED is not set
+CONFIG_MEMCG_KMEM=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="/home/wolfvak/rootfs"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=".gz"
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_HAVE_UID16=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_DEBUG_RSEQ is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_SLUB_MEMCG_SYSFS_ON is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+# CONFIG_PROFILING is not set
+CONFIG_TRACEPOINTS=y
+# end of General setup
+
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+CONFIG_ARCH_MULTI_V6=y
+# CONFIG_ARCH_MULTI_V7 is not set
+CONFIG_ARCH_MULTI_V6_V7=y
+# end of Multiple platform selection
+
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+CONFIG_ARCH_NINTENDO3DS=y
+
+#
+# TI OMAP/AM/DM/DRA Family
+#
+# CONFIG_ARCH_OMAP2 is not set
+# end of TI OMAP/AM/DM/DRA Family
+
+# CONFIG_ARCH_OXNAS is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_WM8750 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V6K=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+CONFIG_DMA_CACHE_RWFO=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_DEBUG_ALIGN_RODATA=y
+# CONFIG_ARM_ERRATA_411920 is not set
+# end of System Type
+
+#
+# Bus support
+#
+# end of Bus support
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+# CONFIG_SMP_ON_UP is not set
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_HAVE_ARM_TWD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+CONFIG_ARCH_NR_GPIO=0
+CONFIG_HZ_FIXED=0
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_200 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# end of Kernel Features
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE=""
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+# end of Boot options
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+# CONFIG_CPU_FREQ_GOV_SCHEDUTIL is not set
+
+#
+# CPU frequency scaling drivers
+#
+# CONFIG_CPUFREQ_DT is not set
+# CONFIG_QORIQ_CPUFREQ is not set
+# end of CPU Frequency scaling
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_CPU_IDLE_GOV_TEO is not set
+CONFIG_DT_IDLE_STATES=y
+
+#
+# ARM CPU Idle Drivers
+#
+CONFIG_ARM_CPUIDLE=y
+# end of ARM CPU Idle Drivers
+# end of CPU Idle
+# end of CPU Power Management
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+# end of Floating point emulation
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_AUTOSLEEP=y
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+# CONFIG_ENERGY_MODEL is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+# end of Power management options
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+# end of Tegra firmware driver
+# end of Firmware Drivers
+
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# General architecture-dependent options
+#
+CONFIG_HAVE_OPROFILE=y
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_KEEPINITRD=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_ARCH_32BIT_OFF_T=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+# CONFIG_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_64BIT_TIME=y
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_ARCH_HAS_PHYS_TO_DMA=y
+CONFIG_REFCOUNT_FULL=y
+# CONFIG_LOCK_EVENT_COUNTS is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# end of GCOV-based kernel profiling
+
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+# CONFIG_BLK_DEV_ZONED is not set
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_DEV_THROTTLING_LOW is not set
+CONFIG_BLK_CMDLINE_PARSER=y
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_CGROUP_IOLATENCY is not set
+# CONFIG_BLK_CGROUP_IOCOST is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+CONFIG_LDM_PARTITION=y
+# CONFIG_LDM_DEBUG is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+# end of Partition Types
+
+CONFIG_BLK_MQ_VIRTIO=y
+CONFIG_BLK_PM=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+# end of IO Schedulers
+
+CONFIG_ASN1=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_ARCH_HAS_BINFMT_FLAT=y
+# CONFIG_BINFMT_FLAT is not set
+CONFIG_BINFMT_FLAT_ARGVP_ENVP_ON_STACK=y
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_CMA is not set
+CONFIG_ZPOOL=y
+# CONFIG_ZBUD is not set
+CONFIG_Z3FOLD=y
+CONFIG_ZSMALLOC=y
+# CONFIG_PGTABLE_MAPPING is not set
+# CONFIG_ZSMALLOC_STAT is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+# end of Memory Management options
+
+# CONFIG_NET is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+CONFIG_HAVE_PCI=y
+# CONFIG_PCI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_MOXTET is not set
+# CONFIG_SIMPLE_PM_BUS is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# end of Bus devices
+
+# CONFIG_GNSS is not set
+CONFIG_MTD=y
+
+#
+# Partition parsers
+#
+# CONFIG_MTD_AR7_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_OF_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# end of Partition parsers
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# end of RAM/ROM/Flash chip drivers
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+# end of Mapping drivers for chip access
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_MCHP23K256 is not set
+CONFIG_MTD_SST25L=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# end of Self-contained MTD device drivers
+
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_RAW_NAND is not set
+# CONFIG_MTD_SPI_NAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+# end of LPDDR & LPDDR2 PCM memory drivers
+
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_SPI_MTK_QUADSPI is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_HYPERBUS is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+CONFIG_BLK_DEV_NULL_BLK=y
+# CONFIG_ZRAM is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+
+#
+# DRBD disabled because PROC_FS or INET not selected
+#
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_CDROM_PKTCDVD is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_VIRTIO_BLK_SCSI is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+# end of EEPROM support
+
+#
+# Texas Instruments shared transport line discipline
+#
+# end of Texas Instruments shared transport line discipline
+
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+# CONFIG_VOP_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# end of Intel MIC & related support
+
+# CONFIG_ECHO is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# end of SCSI Transports
+
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_DEBUG is not set
+CONFIG_SCSI_VIRTIO=y
+# CONFIG_SCSI_DH is not set
+# end of SCSI device support
+
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+CONFIG_INPUT_MATRIXKMAP=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_PROPERTIES=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_BU21029 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
+# CONFIG_TOUCHSCREEN_EXC3000 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GOODIX is not set
+# CONFIG_TOUCHSCREEN_HIDEEP is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_S6SY761 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_EKTF2127 is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_RM_TS is not set
+# CONFIG_TOUCHSCREEN_SILEAD is not set
+# CONFIG_TOUCHSCREEN_SIS_I2C is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZET6223 is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
+# CONFIG_TOUCHSCREEN_IQS5XX is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_MSM_VIBRATOR is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_GPIO_VIBRA is not set
+# CONFIG_INPUT_KXTJ9 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=0
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_N_HDLC is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_NULL_TTY is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# end of Serial drivers
+
+# CONFIG_SERIAL_DEV_BUS is not set
+CONFIG_TTY_PRINTK=y
+CONFIG_TTY_PRINTK_LEVEL=6
+# CONFIG_HVC_DCC is not set
+# CONFIG_VIRTIO_CONSOLE is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_VIRTIO=y
+CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=256
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# end of Character devices
+
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_DEMUX_PINCTRL is not set
+# CONFIG_I2C_MUX_MLXCPLD is not set
+# end of Multiplexer I2C Chip support
+
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# end of I2C Hardware Bus support
+
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_NXP_FLEXSPI is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SIFIVE is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+CONFIG_PINCTRL=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+# CONFIG_PINCTRL_STMFX is not set
+# CONFIG_PINCTRL_OCELOT is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+# end of I2C GPIO expanders
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+# end of MFD GPIO expanders
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# end of SPI GPIO expanders
+
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMKONA is not set
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_VERSATILE is not set
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+# CONFIG_SYSCON_REBOOT_MODE is not set
+# CONFIG_NVMEM_REBOOT_MODE is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD70528 is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_STMFX is not set
+# end of Multifunction device drivers
+
+# CONFIG_REGULATOR is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_IMX_IPUV3_CORE is not set
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ARM devices
+#
+# end of ARM devices
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# end of ACP (Audio CoProcessor) Configuration
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+CONFIG_FB_SIMPLE=y
+# CONFIG_FB_SSD1307 is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_HX8357 is not set
+# CONFIG_LCD_OTM3225A is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_PM8941_WLED is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+# end of Backlight & LCD device support
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
+# end of Console display driver support
+
+# CONFIG_LOGO is not set
+# end of Graphics support
+
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+# CONFIG_HID is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+# end of I2C HID support
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3532 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_USER is not set
+# CONFIG_LEDS_SPI_BYTE is not set
+# CONFIG_LEDS_TI_LMU_COMMON is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABEOZ9 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3028 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_SD3078 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_DW_AXI_DMAC is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_FSL_QDMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_NBPFAXI_DMA is not set
+CONFIG_PL330_DMA=y
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+CONFIG_UIO_PDRV_GENIRQ=y
+CONFIG_UIO_DMEM_GENIRQ=y
+# CONFIG_UIO_PRUSS is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO=y
+# CONFIG_VIRTIO_MENU is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+# CONFIG_STAGING is not set
+CONFIG_NINTENDO3DS_PLATFORM_DEVICES=y
+CONFIG_NINTENDO3DS_HID=y
+CONFIG_NINTENDO3DS_SPI=y
+CONFIG_NINTENDO3DS_CODEC=y
+CONFIG_NINTENDO3DS_PXI=y
+CONFIG_NINTENDO3DS_I2C=y
+CONFIG_NINTENDO3DS_MCU=y
+CONFIG_NINTENDO3DS_RTC=y
+CONFIG_NINTENDO3DS_LEDS=y
+CONFIG_NINTENDO3DS_RESET=y
+CONFIG_NINTENDO3DS_MCUHID=y
+CONFIG_NINTENDO3DS_CHARGER=y
+CONFIG_NINTENDO3DS_BACKLIGHT=y
+# CONFIG_GOLDFISH is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+# end of Common Clock Framework
+
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+# end of Clock Source drivers
+
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Aspeed SoC drivers
+#
+# end of Aspeed SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# end of i.MX SoC drivers
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_AL_FIC is not set
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_TI_SYSCON is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_DP is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# CONFIG_ARM_CCN is not set
+CONFIG_ARM_PMU=y
+# end of Performance monitor support
+
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# end of Android
+
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+# end of Device Drivers
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_FS_IOMAP=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT2=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_F2FS_FS=y
+CONFIG_F2FS_STAT_FS=y
+CONFIG_F2FS_FS_XATTR=y
+CONFIG_F2FS_FS_POSIX_ACL=y
+# CONFIG_F2FS_FS_SECURITY is not set
+# CONFIG_F2FS_CHECK_FS is not set
+# CONFIG_F2FS_FAULT_INJECTION is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+CONFIG_FS_ENCRYPTION=y
+# CONFIG_FS_VERITY is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+# CONFIG_VIRTIO_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=y
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+# end of DOS/FAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_MEMFD_CREATE=y
+CONFIG_CONFIGFS_FS=y
+# end of Pseudo filesystems
+
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_KOI8_R=y
+CONFIG_NLS_KOI8_U=y
+CONFIG_NLS_MAC_ROMAN=y
+CONFIG_NLS_MAC_CELTIC=y
+CONFIG_NLS_MAC_CENTEURO=y
+CONFIG_NLS_MAC_CROATIAN=y
+CONFIG_NLS_MAC_CYRILLIC=y
+CONFIG_NLS_MAC_GAELIC=y
+CONFIG_NLS_MAC_GREEK=y
+CONFIG_NLS_MAC_ICELAND=y
+CONFIG_NLS_MAC_INUIT=y
+CONFIG_NLS_MAC_ROMANIAN=y
+CONFIG_NLS_MAC_TURKISH=y
+CONFIG_NLS_UTF8=y
+# CONFIG_UNICODE is not set
+# end of File systems
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+CONFIG_PERSISTENT_KEYRINGS=y
+CONFIG_BIG_KEYS=y
+CONFIG_ENCRYPTED_KEYS=y
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+# CONFIG_SECURITY_NETWORK is not set
+CONFIG_SECURITY_PATH=y
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+# CONFIG_SECURITY_LOADPIN is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_SECURITY_SAFESETID is not set
+# CONFIG_SECURITY_LOCKDOWN_LSM is not set
+# CONFIG_INTEGRITY is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_CRYPTD=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_ENGINE=y
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+# CONFIG_CRYPTO_ECRDSA is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CHACHA20POLY1305=y
+# CONFIG_CRYPTO_AEGIS128 is not set
+CONFIG_CRYPTO_SEQIV=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CFB is not set
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=y
+# CONFIG_CRYPTO_OFB is not set
+CONFIG_CRYPTO_PCBC=y
+CONFIG_CRYPTO_XTS=y
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+# CONFIG_CRYPTO_ESSIV is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=y
+CONFIG_CRYPTO_VMAC=y
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32=y
+# CONFIG_CRYPTO_XXHASH is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_POLY1305=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+CONFIG_CRYPTO_ANUBIS=y
+CONFIG_CRYPTO_LIB_ARC4=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_BLOWFISH_COMMON=y
+CONFIG_CRYPTO_CAMELLIA=y
+CONFIG_CRYPTO_CAST_COMMON=y
+CONFIG_CRYPTO_CAST5=y
+CONFIG_CRYPTO_CAST6=y
+CONFIG_CRYPTO_LIB_DES=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_FCRYPT=y
+CONFIG_CRYPTO_KHAZAD=y
+CONFIG_CRYPTO_SALSA20=y
+CONFIG_CRYPTO_CHACHA20=y
+CONFIG_CRYPTO_SEED=y
+CONFIG_CRYPTO_SERPENT=y
+# CONFIG_CRYPTO_SM4 is not set
+CONFIG_CRYPTO_TEA=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRYPTO_842=y
+CONFIG_CRYPTO_LZ4=y
+CONFIG_CRYPTO_LZ4HC=y
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+CONFIG_CRYPTO_DEV_VIRTIO=y
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+# CONFIG_PKCS8_PRIVATE_KEY_PARSER is not set
+CONFIG_PKCS7_MESSAGE_PARSER=y
+
+#
+# Certificates for signature checking
+#
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# end of Certificates for signature checking
+
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_CORDIC=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+CONFIG_CRC8=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_842_COMPRESS=y
+CONFIG_842_DECOMPRESS=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_COMPRESS=y
+CONFIG_LZ4HC_COMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_ARCH_HAS_SETUP_DMA_OPS=y
+CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS=y
+CONFIG_DMA_REMAP=y
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_CLZ_TAB=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_FONT_SUPPORT=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+# CONFIG_FONT_8x16 is not set
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_6x10 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_TER16x32 is not set
+CONFIG_SG_POOL=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_DEBUG_INFO_BTF is not set
+# CONFIG_GDB_SCRIPTS is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_INSTALL is not set
+CONFIG_OPTIMIZE_INLINING=y
+CONFIG_DEBUG_SECTION_MISMATCH=y
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_MISC=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_PAGE_POISONING=y
+# CONFIG_PAGE_POISONING_NO_SANITY is not set
+# CONFIG_PAGE_POISONING_ZERO is not set
+# CONFIG_DEBUG_PAGE_REF is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_CC_HAS_KASAN_GENERIC=y
+CONFIG_KASAN_STACK=1
+# end of Memory Debugging
+
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=10
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_WQ_WATCHDOG=y
+# end of Debug Lockups and Hangs
+
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHED_INFO=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+CONFIG_PROVE_LOCKING=y
+# CONFIG_LOCK_STAT is not set
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
+CONFIG_DEBUG_RWSEMS=y
+CONFIG_DEBUG_LOCK_ALLOC=y
+CONFIG_LOCKDEP=y
+# CONFIG_DEBUG_LOCKDEP is not set
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+CONFIG_TRACE_IRQFLAGS=y
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_LIST=y
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+CONFIG_PROVE_RCU=y
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+CONFIG_NOTIFIER_ERROR_INJECTION=y
+# CONFIG_PM_NOTIFIER_ERROR_INJECT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_PREEMPTIRQ_TRACEPOINTS=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
+# CONFIG_MEMTEST is not set
+CONFIG_BUG_ON_DATA_CORRUPTION=y
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_UBSAN is not set
+CONFIG_UBSAN_ALIGNMENT=y
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_IO_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP_DEBUGFS is not set
+# CONFIG_DEBUG_WX is not set
+# CONFIG_UNWINDER_FRAME_POINTER is not set
+CONFIG_UNWINDER_ARM=y
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
+# end of Kernel hacking
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/kernel/smp.c linux-3ds/arch/arm/kernel/smp.c
--- linux-5.4.12/arch/arm/kernel/smp.c	2020-01-14 16:08:40.000000000 -0300
+++ linux-3ds/arch/arm/kernel/smp.c	2020-01-17 09:02:23.749993635 -0300
@@ -517,7 +517,7 @@
 	S(IPI_COMPLETION, "completion interrupts"),
 };
 
-static void smp_cross_call(const struct cpumask *target, unsigned int ipinr)
+void smp_cross_call(const struct cpumask *target, unsigned int ipinr)
 {
 	trace_ipi_raise_rcuidle(target, ipi_types[ipinr]);
 	__smp_cross_call(target, ipinr);
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/Kconfig linux-3ds/arch/arm/mach-nintendo3ds/Kconfig
--- linux-5.4.12/arch/arm/mach-nintendo3ds/Kconfig	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/Kconfig	2020-01-17 13:57:53.102464186 -0300
@@ -0,0 +1,17 @@
+config ARCH_NINTENDO3DS
+	bool "Nintendo 3DS"
+	select ARM_GIC
+	select ARM_AMBA
+	select CPU_V6K
+	select HAVE_SMP
+	select HAVE_ARM_SCU
+	select HAVE_ARM_TWD
+	select GENERIC_IRQ_CHIP
+	select GENERIC_CLOCKEVENTS
+	select CLKDEV_LOOKUP
+	select COMMON_CLK
+	select GENERIC_CLOCKEVENTS
+	select SOC_BUS
+	select USE_OF
+	help
+	  Support for the Nintendo 3DS game console.
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/Makefile linux-3ds/arch/arm/mach-nintendo3ds/Makefile
--- linux-5.4.12/arch/arm/mach-nintendo3ds/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/Makefile	2020-01-17 15:43:17.228021125 -0300
@@ -0,0 +1,7 @@
+
+ccflags-$(CONFIG_ARCH_MULTIPLATFORM) := -I$(srctree)/$(src)/include
+
+obj-$(CONFIG_ARCH_NINTENDO3DS) += nintendo3ds_ctr.o
+obj-$(CONFIG_ARCH_NINTENDO3DS) += bottom_lcd.o
+obj-$(CONFIG_SMP) += platsmp.o
+obj-$(CONFIG_SMP) += headsmp.o
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/Makefile.boot linux-3ds/arch/arm/mach-nintendo3ds/Makefile.boot
--- linux-5.4.12/arch/arm/mach-nintendo3ds/Makefile.boot	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/Makefile.boot	2020-01-17 09:02:23.764000634 -0300
@@ -0,0 +1,3 @@
+zreladdr-y     += 0x20008000
+params_phys-y  := 0x20000100
+initrd_phys-y  := 0x20000000
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/bottom_lcd.c linux-3ds/arch/arm/mach-nintendo3ds/bottom_lcd.c
--- linux-5.4.12/arch/arm/mach-nintendo3ds/bottom_lcd.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/bottom_lcd.c	2020-01-17 11:07:43.121644816 -0300
@@ -0,0 +1,145 @@
+/*
+ *  Nintendo 3DS bottom_lcd.c
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  Copyright (C) 2017 Paul LaMendola (paulguy)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/ioport.h>
+
+#include <mach/platform.h>
+#include <mach/bottom_lcd.h>
+
+static u8 __iomem *bottom_lcd_fb = NULL;
+
+void nintendo3ds_bottom_setup_fb(void)
+{
+	u8 __iomem *lcd_fb_pdc1_base;
+
+	if (request_mem_region(NINTENDO3DS_GPU_REG_LCD_FB_PDC1, NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE, "N3DS_LCD_FB_PDC1")) {
+		lcd_fb_pdc1_base = ioremap_nocache(NINTENDO3DS_GPU_REG_LCD_FB_PDC1, NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE);
+
+		printk("LCD_FB_PDC1 mapped to: %p - %p\n", lcd_fb_pdc1_base,
+			lcd_fb_pdc1_base +
+			NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE);
+	} else {
+		printk("LCD_FB_PDC1 region not available.\n");
+		return;
+	}
+
+	iowrite32((NINTENDO3DS_LCD_BOT_HEIGHT << 16)
+		| NINTENDO3DS_LCD_TOP_WIDTH, lcd_fb_pdc1_base + 0x5C);
+	iowrite32(NINTENDO3DS_FB_BOT_1, lcd_fb_pdc1_base + 0x68);
+	iowrite32(NINTENDO3DS_FB_BOT_2, lcd_fb_pdc1_base + 0x6C);
+	iowrite32(0b000001, lcd_fb_pdc1_base + 0x70);
+	iowrite32(0, lcd_fb_pdc1_base + 0x78);
+	iowrite32(NINTENDO3DS_LCD_BOT_HEIGHT * 3, lcd_fb_pdc1_base + 0x90);
+
+	iounmap(lcd_fb_pdc1_base);
+	release_mem_region(NINTENDO3DS_GPU_REG_LCD_FB_PDC1,
+		NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE);
+}
+
+void nintendo3ds_bottom_lcd_map_fb(void)
+{
+	/* Map bottom screen framebuffer (VRAM) */
+	if (request_mem_region(NINTENDO3DS_FB_BOT_1, NINTENDO3DS_FB_BOT_SIZE, "N3DS_BOT_FB")) {
+		bottom_lcd_fb = ioremap_nocache(NINTENDO3DS_FB_BOT_1, NINTENDO3DS_FB_BOT_SIZE);
+
+		printk("Nintendo 3DS: Bottom LCD FB mapped to: %p - %p\n",
+			bottom_lcd_fb, bottom_lcd_fb + NINTENDO3DS_FB_BOT_SIZE);
+	} else {
+		printk("Nintendo 3DS: Bottom LCD FB region not available.\n");
+	}
+}
+
+void nintendo3ds_bottom_lcd_unmap_fb(void)
+{
+	if (bottom_lcd_fb) {
+		iounmap(bottom_lcd_fb);
+		release_mem_region(NINTENDO3DS_FB_BOT_1, NINTENDO3DS_FB_BOT_SIZE);
+	}
+}
+
+void nintendo3ds_bottom_lcd_draw_pixel(int x, int y, unsigned int color)
+{
+	u8 __iomem *dst;
+
+	if (x < 0 || y < 0)
+		return;
+
+	dst = bottom_lcd_fb + ((NINTENDO3DS_LCD_BOT_HEIGHT - y - 1) +
+		x * NINTENDO3DS_LCD_BOT_HEIGHT) * 3;
+	iowrite8((color >> 0 ) & 0xFF, dst + 0);
+	iowrite8((color >> 8 ) & 0xFF, dst + 1);
+	iowrite8((color >> 16) & 0xFF, dst + 2);
+}
+
+void nintendo3ds_bottom_lcd_draw_fillrect(int x, int y, int w, int h, unsigned int color)
+{
+	int i, j;
+	for (i = 0; i < h; i++)
+		for (j = 0; j < w; j++)
+			nintendo3ds_bottom_lcd_draw_pixel(x + j, y + i, color);
+}
+
+void nintendo3ds_bottom_lcd_clear_screen(unsigned int color)
+{
+	nintendo3ds_bottom_lcd_draw_fillrect(0, 0, NINTENDO3DS_LCD_BOT_WIDTH, NINTENDO3DS_LCD_BOT_HEIGHT, color);
+}
+
+void nintendo3ds_bottom_lcd_draw_char(const struct font_desc *font, int x, int y, unsigned int color, char c)
+{
+	int i, j;
+	const u8 *src;
+
+	src = font->data + c * font->height;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 0; j < 8; j++) {
+			if ((*src & (128 >> j)))
+				nintendo3ds_bottom_lcd_draw_pixel(x+j, y+i, color);
+		}
+		src++;
+	}
+}
+
+int nintendo3ds_bottom_lcd_draw_text(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text)
+{
+	char c;
+	int sx = x;
+
+	if (!text)
+		return 0;
+
+	while ((c = *text++)) {
+		if (c == '\n') {
+			x = sx;
+			y += font->height;
+		} else if (c == ' ') {
+			x += font->width;
+		} else if(c == '\t') {
+			x += 4 * font->width;
+		} else {
+			nintendo3ds_bottom_lcd_draw_fillrect(x, y, font->width, font->height, bgcolor);
+			nintendo3ds_bottom_lcd_draw_char(font, x, y, fgcolor, c);
+			x += font->width;
+		}
+	}
+
+	return x - sx;
+}
+
+void nintendo3ds_bottom_lcd_draw_textf(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text, ...)
+{
+	char buffer[256];
+	va_list args;
+	va_start(args, text);
+	vsnprintf(buffer, 256, text, args);
+	nintendo3ds_bottom_lcd_draw_text(font, x, y, bgcolor, fgcolor, buffer);
+	va_end(args);
+}
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/headsmp.S linux-3ds/arch/arm/mach-nintendo3ds/headsmp.S
--- linux-5.4.12/arch/arm/mach-nintendo3ds/headsmp.S	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/headsmp.S	2020-01-17 09:02:23.750994135 -0300
@@ -0,0 +1,38 @@
+/*
+ *  linux/arch/arm/mach-nintendo3ds/headsmp.S
+ *
+ *  Cloned from linux/arch/arm/plat-versatile/headsmp.S
+ *
+ *  Copyright (c) 2016 Sergi Granell <xerpi.g.12@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+/*
+ * CPU1 comes with the cache dirty from the bootrom,
+ * so clean the cache before jumping to the kernel.
+ */
+
+ENTRY(nintendo3ds_secondary_startup)
+	cpsid aif
+
+	mov r0, #0
+
+	/* Invalidate Both Caches & flush the branch target cache */
+	mcr p15, 0, r0, c7, c7, 0
+
+	/* Flush Prefetch Buffer */
+	mcr p15, 0, r0, c7, c5, 4
+
+	/* Flush Entire Branch Target Cache */
+	mcr p15, 0, r0, c7, c5, 6
+
+	/* Data Synchronization Barrier */
+	mcr p15, 0, r0, c7, c10, 4
+
+    b secondary_startup
+ENDPROC(nintendo3ds_secondary_startup)
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/bottom_lcd.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/bottom_lcd.h
--- linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/bottom_lcd.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/bottom_lcd.h	2020-01-17 09:02:23.750994135 -0300
@@ -0,0 +1,42 @@
+/*
+ *  Nintendo 3DS bottom_lcd.h
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  Copyright (C) 2017 Paul LaMendola (paulguy)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __NINTENDO3DS_BOTTOM_LCD_H
+#define __NINTENDO3DS_BOTTOM_LCD_H
+
+#include <linux/font.h>
+#include <asm/io.h>
+
+#define COLOR_RED		0xFF0000
+#define COLOR_GREEN		0x00FF00
+#define COLOR_BLUE		0x0000FF
+#define COLOR_CYAN		0x00FFFF
+#define COLOR_PINK		0xFF00FF
+#define COLOR_YELLOW		0xFFFF00
+#define COLOR_BLACK		0x000000
+#define COLOR_GREY		0x808080
+#define COLOR_WHITE		0xFFFFFF
+#define COLOR_ORANGE		0xFF9900
+#define COLOR_LIGHT_GREEN	0x00CC00
+#define COLOR_PURPLE		0x660033
+
+void nintendo3ds_bottom_setup_fb(void);
+void nintendo3ds_bottom_lcd_map_fb(void);
+void nintendo3ds_bottom_lcd_unmap_fb(void);
+
+void nintendo3ds_bottom_lcd_draw_pixel(int x, int y, unsigned int color);
+void nintendo3ds_bottom_lcd_draw_fillrect(int x, int y, int w, int h, unsigned int color);
+void nintendo3ds_bottom_lcd_clear_screen(unsigned int color);
+void nintendo3ds_bottom_lcd_draw_char(const struct font_desc *font, int x, int y, unsigned int color, char c);
+int nintendo3ds_bottom_lcd_draw_text(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text);
+void nintendo3ds_bottom_lcd_draw_textf(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text, ...);
+
+#endif
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/debug-macro.S linux-3ds/arch/arm/mach-nintendo3ds/include/mach/debug-macro.S
--- linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/debug-macro.S	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/debug-macro.S	2020-01-17 09:02:23.750994135 -0300
@@ -0,0 +1,47 @@
+#ifdef CONFIG_DEBUG_LL_NINTENDO3DS_ARM9
+
+#define EARLY_SHARED_BUF_PA (0x20000000)
+
+.macro	addruart,rp,rv,tmp
+	mov	\rp, #EARLY_SHARED_BUF_PA
+	mov	\rv, #(EARLY_SHARED_BUF_PA - CONFIG_PHYS_OFFSET + CONFIG_PAGE_OFFSET)
+.endm
+
+.macro	senduart,rd,rx
+	strb	\rd, [\rx]
+	# Clean and Invalidate Entire Data Cache
+	# Data Synchronization Barrier
+	mov	\rd, #0
+	mcr	p15, 0, \rd, c7, c14, 0
+	mcr 	p15, 0, \rd, c7, c10, 4
+.endm
+
+.macro	busyuart,rd,rx
+99:
+	# Invalidate Entire Data Cache
+	mov	\rd, #0
+	mcr	p15, 0, \rd, c7, c6, 0
+
+	ldrb	\rd, [\rx]
+	cmp	\rd, #0
+	bne	99b
+.endm
+
+.macro	waituart,rd,rx
+.endm
+
+#else
+
+.macro	addruart,rp,rv,tmp
+.endm
+
+.macro	senduart,rd,rx
+.endm
+
+.macro	busyuart,rd,rx
+.endm
+
+.macro	waituart,rd,rx
+.endm
+
+#endif
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/entry-macro.S linux-3ds/arch/arm/mach-nintendo3ds/include/mach/entry-macro.S
--- linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/entry-macro.S	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/entry-macro.S	2020-01-17 09:02:23.752995134 -0300
@@ -0,0 +1,12 @@
+
+
+.macro  get_irqnr_preamble, base, tmp
+ldr	\base, =0
+.endm
+
+.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+ldr	\irqstat, [\base, #0]
+clz	\irqnr, \irqstat
+rsb	\irqnr, \irqnr, #31
+teq	\irqstat, #0
+.endm
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/hardware.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/hardware.h
--- linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/hardware.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/hardware.h	2020-01-17 09:24:04.752749868 -0300
@@ -0,0 +1,19 @@
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+/* macro to get at IO space when running virtually */
+#ifdef CONFIG_MMU
+/*
+ * Statically mapped addresses:
+ *
+ * 10xx xxxx -> fbxx xxxx
+ * 1exx xxxx -> fdxx xxxx
+ * 1fxx xxxx -> fexx xxxx
+ */
+#define IO_ADDRESS(x)		(((x) & 0x03ffffff) + 0xfb000000)
+#else
+#define IO_ADDRESS(x)		(x)
+#endif
+#define __io_address(n)		IOMEM(IO_ADDRESS(n))
+
+#endif
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/irqs.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/irqs.h
--- linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/irqs.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/irqs.h	2020-01-17 09:02:23.752995134 -0300
@@ -0,0 +1,8 @@
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+
+#define NR_IRQS 128
+
+
+#endif
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/platform.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/platform.h
--- linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/platform.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/platform.h	2020-01-17 09:02:23.757997634 -0300
@@ -0,0 +1,44 @@
+#ifndef __ASM_ARCH_PLATFORM_H
+#define __ASM_ARCH_PLATFORM_H
+
+
+/* Memory layout */
+
+#define NINTENDO3DS_CTR_VRAM_BASE	(0x18000000)
+#define NINTENDO3DS_CTR_VRAM_SIZE	(0x00600000)
+#define NINTENDO3DS_CTR_AXI_WRAM_BASE	(0x1FF80000)
+#define NINTENDO3DS_CTR_AXI_WRAM_SIZE	(0x00080000)
+#define NINTENDO3DS_CTR_FCRAM_BASE	(0x20000000)
+#define NINTENDO3DS_CTR_FCRAM_SIZE	(0x08000000)
+
+/* PDN Registers */
+
+#define NINTENDO3DS_REG_PDN_SPI_CNT	(0x101401C0)
+
+/* GPU External registers */
+
+#define NINTENDO3DS_LCD_TOP_WIDTH	(400)
+#define NINTENDO3DS_LCD_BOT_WIDTH	(320)
+#define NINTENDO3DS_LCD_TOP_HEIGHT	(240)
+#define NINTENDO3DS_LCD_BOT_HEIGHT	(240)
+
+#define NINTENDO3DS_GPU_REG_LCD_FB_PDC0		(0x10400400)
+#define NINTENDO3DS_GPU_REG_LCD_FB_PDC1		(0x10400500)
+
+#define NINTENDO3DS_GPU_REG_LCD_FB_PDC_SIZE		(0x100)
+
+#define NINTENDO3DS_GPU_REG_LCD_FB_A_ADDR_OFFSET	(0x68)
+#define NINTENDO3DS_GPU_REG_LCD_FB_B_ADDR_OFFSET 	(0x94)
+
+/* Framebuffer setup */
+
+#define NINTENDO3DS_FB_TOP_SIZE		(NINTENDO3DS_LCD_TOP_WIDTH * NINTENDO3DS_LCD_TOP_HEIGHT * 3)
+#define NINTENDO3DS_FB_BOT_SIZE		(NINTENDO3DS_LCD_TOP_WIDTH * NINTENDO3DS_LCD_TOP_HEIGHT * 3)
+#define NINTENDO3DS_FB_TOP_LEFT1	(NINTENDO3DS_CTR_VRAM_BASE)
+#define NINTENDO3DS_FB_TOP_LEFT2	(NINTENDO3DS_FB_TOP_LEFT1  + NINTENDO3DS_FB_TOP_SIZE)
+#define NINTENDO3DS_FB_TOP_RIGHT1	(NINTENDO3DS_FB_TOP_LEFT2  + NINTENDO3DS_FB_TOP_SIZE)
+#define NINTENDO3DS_FB_TOP_RIGHT2	(NINTENDO3DS_FB_TOP_RIGHT1 + NINTENDO3DS_FB_TOP_SIZE)
+#define NINTENDO3DS_FB_BOT_1		(NINTENDO3DS_FB_TOP_RIGHT2 + NINTENDO3DS_FB_TOP_SIZE)
+#define NINTENDO3DS_FB_BOT_2		(NINTENDO3DS_FB_BOT_1      + NINTENDO3DS_FB_BOT_SIZE)
+
+#endif	/* __ASM_ARCH_PLATFORM_H */
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/platsmp.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/platsmp.h
--- linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/platsmp.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/platsmp.h	2020-01-17 09:02:23.758998134 -0300
@@ -0,0 +1,11 @@
+/*
+ *  linux/arch/arm/mach-nintendo3ds/include/mach/platsmp.h
+ *
+ *  Copyright (c) 2016 Sergi Granell <xerpi.g.12@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+extern void nintendo3ds_secondary_startup(void);
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/uncompress.h linux-3ds/arch/arm/mach-nintendo3ds/include/mach/uncompress.h
--- linux-5.4.12/arch/arm/mach-nintendo3ds/include/mach/uncompress.h	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/include/mach/uncompress.h	2020-01-17 09:02:23.760999134 -0300
@@ -0,0 +1,208 @@
+//#include <mach/nintendo3ds.h>
+
+#define VRAM_BASE             (0x18000000)
+#define FB_BASE_PA            (VRAM_BASE)
+#define FB_TOP_SIZE           (400*240*3)
+#define FB_BOT_SIZE           (320*240*3)
+#define FB_TOP_LEFT1          (FB_BASE_PA)
+#define FB_TOP_LEFT2          (FB_TOP_LEFT1  + FB_TOP_SIZE)
+#define FB_TOP_RIGHT1         (FB_TOP_LEFT2  + FB_TOP_SIZE)
+#define FB_TOP_RIGHT2         (FB_TOP_RIGHT1 + FB_TOP_SIZE)
+#define FB_BOT_1              (FB_TOP_RIGHT2 + FB_TOP_SIZE)
+#define FB_BOT_2              (FB_BOT_1      + FB_BOT_SIZE)
+#define SCREEN_TOP_W  (400)
+#define SCREEN_BOT_W  (320)
+#define SCREEN_TOP_H  (240)
+#define SCREEN_BOT_H  (240)
+
+#define RED	   0xFF0000
+#define GREEN  0x00FF00
+#define BLUE   0x0000FF
+#define CYAN   0x00FFFF
+#define BLACK  0x000000
+#define WHITE  0xFFFFFF
+
+static const unsigned char msx_font[] __attribute((aligned(4))) =
+"\x00\x00\x00\x00\x00\x00\x00\x00\x3c\x42\xa5\x81\xa5\x99\x42\x3c"
+"\x3c\x7e\xdb\xff\xff\xdb\x66\x3c\x6c\xfe\xfe\xfe\x7c\x38\x10\x00"
+"\x10\x38\x7c\xfe\x7c\x38\x10\x00\x10\x38\x54\xfe\x54\x10\x38\x00"
+"\x10\x38\x7c\xfe\xfe\x10\x38\x00\x00\x00\x00\x30\x30\x00\x00\x00"
+"\xff\xff\xff\xe7\xe7\xff\xff\xff\x38\x44\x82\x82\x82\x44\x38\x00"
+"\xc7\xbb\x7d\x7d\x7d\xbb\xc7\xff\x0f\x03\x05\x79\x88\x88\x88\x70"
+"\x38\x44\x44\x44\x38\x10\x7c\x10\x30\x28\x24\x24\x28\x20\xe0\xc0"
+"\x3c\x24\x3c\x24\x24\xe4\xdc\x18\x10\x54\x38\xee\x38\x54\x10\x00"
+"\x10\x10\x10\x7c\x10\x10\x10\x10\x10\x10\x10\xff\x00\x00\x00\x00"
+"\x00\x00\x00\xff\x10\x10\x10\x10\x10\x10\x10\xf0\x10\x10\x10\x10"
+"\x10\x10\x10\x1f\x10\x10\x10\x10\x10\x10\x10\xff\x10\x10\x10\x10"
+"\x10\x10\x10\x10\x10\x10\x10\x10\x00\x00\x00\xff\x00\x00\x00\x00"
+"\x00\x00\x00\x1f\x10\x10\x10\x10\x00\x00\x00\xf0\x10\x10\x10\x10"
+"\x10\x10\x10\x1f\x00\x00\x00\x00\x10\x10\x10\xf0\x00\x00\x00\x00"
+"\x81\x42\x24\x18\x18\x24\x42\x81\x01\x02\x04\x08\x10\x20\x40\x80"
+"\x80\x40\x20\x10\x08\x04\x02\x01\x00\x10\x10\xff\x10\x10\x00\x00"
+"\x00\x00\x00\x00\x00\x00\x00\x00\x20\x20\x20\x20\x00\x00\x20\x00"
+"\x50\x50\x50\x00\x00\x00\x00\x00\x50\x50\xf8\x50\xf8\x50\x50\x00"
+"\x20\x78\xa0\x70\x28\xf0\x20\x00\xc0\xc8\x10\x20\x40\x98\x18\x00"
+"\x40\xa0\x40\xa8\x90\x98\x60\x00\x10\x20\x40\x00\x00\x00\x00\x00"
+"\x10\x20\x40\x40\x40\x20\x10\x00\x40\x20\x10\x10\x10\x20\x40\x00"
+"\x20\xa8\x70\x20\x70\xa8\x20\x00\x00\x20\x20\xf8\x20\x20\x00\x00"
+"\x00\x00\x00\x00\x00\x20\x20\x40\x00\x00\x00\x78\x00\x00\x00\x00"
+"\x00\x00\x00\x00\x00\x60\x60\x00\x00\x00\x08\x10\x20\x40\x80\x00"
+"\x70\x88\x98\xa8\xc8\x88\x70\x00\x20\x60\xa0\x20\x20\x20\xf8\x00"
+"\x70\x88\x08\x10\x60\x80\xf8\x00\x70\x88\x08\x30\x08\x88\x70\x00"
+"\x10\x30\x50\x90\xf8\x10\x10\x00\xf8\x80\xe0\x10\x08\x10\xe0\x00"
+"\x30\x40\x80\xf0\x88\x88\x70\x00\xf8\x88\x10\x20\x20\x20\x20\x00"
+"\x70\x88\x88\x70\x88\x88\x70\x00\x70\x88\x88\x78\x08\x10\x60\x00"
+"\x00\x00\x20\x00\x00\x20\x00\x00\x00\x00\x20\x00\x00\x20\x20\x40"
+"\x18\x30\x60\xc0\x60\x30\x18\x00\x00\x00\xf8\x00\xf8\x00\x00\x00"
+"\xc0\x60\x30\x18\x30\x60\xc0\x00\x70\x88\x08\x10\x20\x00\x20\x00"
+"\x70\x88\x08\x68\xa8\xa8\x70\x00\x20\x50\x88\x88\xf8\x88\x88\x00"
+"\xf0\x48\x48\x70\x48\x48\xf0\x00\x30\x48\x80\x80\x80\x48\x30\x00"
+"\xe0\x50\x48\x48\x48\x50\xe0\x00\xf8\x80\x80\xf0\x80\x80\xf8\x00"
+"\xf8\x80\x80\xf0\x80\x80\x80\x00\x70\x88\x80\xb8\x88\x88\x70\x00"
+"\x88\x88\x88\xf8\x88\x88\x88\x00\x70\x20\x20\x20\x20\x20\x70\x00"
+"\x38\x10\x10\x10\x90\x90\x60\x00\x88\x90\xa0\xc0\xa0\x90\x88\x00"
+"\x80\x80\x80\x80\x80\x80\xf8\x00\x88\xd8\xa8\xa8\x88\x88\x88\x00"
+"\x88\xc8\xc8\xa8\x98\x98\x88\x00\x70\x88\x88\x88\x88\x88\x70\x00"
+"\xf0\x88\x88\xf0\x80\x80\x80\x00\x70\x88\x88\x88\xa8\x90\x68\x00"
+"\xf0\x88\x88\xf0\xa0\x90\x88\x00\x70\x88\x80\x70\x08\x88\x70\x00"
+"\xf8\x20\x20\x20\x20\x20\x20\x00\x88\x88\x88\x88\x88\x88\x70\x00"
+"\x88\x88\x88\x88\x50\x50\x20\x00\x88\x88\x88\xa8\xa8\xd8\x88\x00"
+"\x88\x88\x50\x20\x50\x88\x88\x00\x88\x88\x88\x70\x20\x20\x20\x00"
+"\xf8\x08\x10\x20\x40\x80\xf8\x00\x70\x40\x40\x40\x40\x40\x70\x00"
+"\x00\x00\x80\x40\x20\x10\x08\x00\x70\x10\x10\x10\x10\x10\x70\x00"
+"\x20\x50\x88\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf8\x00"
+"\x40\x20\x10\x00\x00\x00\x00\x00\x00\x00\x70\x08\x78\x88\x78\x00"
+"\x80\x80\xb0\xc8\x88\xc8\xb0\x00\x00\x00\x70\x88\x80\x88\x70\x00"
+"\x08\x08\x68\x98\x88\x98\x68\x00\x00\x00\x70\x88\xf8\x80\x70\x00"
+"\x10\x28\x20\xf8\x20\x20\x20\x00\x00\x00\x68\x98\x98\x68\x08\x70"
+"\x80\x80\xf0\x88\x88\x88\x88\x00\x20\x00\x60\x20\x20\x20\x70\x00"
+"\x10\x00\x30\x10\x10\x10\x90\x60\x40\x40\x48\x50\x60\x50\x48\x00"
+"\x60\x20\x20\x20\x20\x20\x70\x00\x00\x00\xd0\xa8\xa8\xa8\xa8\x00"
+"\x00\x00\xb0\xc8\x88\x88\x88\x00\x00\x00\x70\x88\x88\x88\x70\x00"
+"\x00\x00\xb0\xc8\xc8\xb0\x80\x80\x00\x00\x68\x98\x98\x68\x08\x08"
+"\x00\x00\xb0\xc8\x80\x80\x80\x00\x00\x00\x78\x80\xf0\x08\xf0\x00"
+"\x40\x40\xf0\x40\x40\x48\x30\x00\x00\x00\x90\x90\x90\x90\x68\x00"
+"\x00\x00\x88\x88\x88\x50\x20\x00\x00\x00\x88\xa8\xa8\xa8\x50\x00"
+"\x00\x00\x88\x50\x20\x50\x88\x00\x00\x00\x88\x88\x98\x68\x08\x70"
+"\x00\x00\xf8\x10\x20\x40\xf8\x00\x18\x20\x20\x40\x20\x20\x18\x00"
+"\x20\x20\x20\x00\x20\x20\x20\x00\xc0\x20\x20\x10\x20\x20\xc0\x00"
+"\x40\xa8\x10\x00\x00\x00\x00\x00\x00\x00\x20\x50\xf8\x00\x00\x00"
+"\x70\x88\x80\x80\x88\x70\x20\x60\x90\x00\x00\x90\x90\x90\x68\x00"
+"\x10\x20\x70\x88\xf8\x80\x70\x00\x20\x50\x70\x08\x78\x88\x78\x00"
+"\x48\x00\x70\x08\x78\x88\x78\x00\x20\x10\x70\x08\x78\x88\x78\x00"
+"\x20\x00\x70\x08\x78\x88\x78\x00\x00\x70\x80\x80\x80\x70\x10\x60"
+"\x20\x50\x70\x88\xf8\x80\x70\x00\x50\x00\x70\x88\xf8\x80\x70\x00"
+"\x20\x10\x70\x88\xf8\x80\x70\x00\x50\x00\x00\x60\x20\x20\x70\x00"
+"\x20\x50\x00\x60\x20\x20\x70\x00\x40\x20\x00\x60\x20\x20\x70\x00"
+"\x50\x00\x20\x50\x88\xf8\x88\x00\x20\x00\x20\x50\x88\xf8\x88\x00"
+"\x10\x20\xf8\x80\xf0\x80\xf8\x00\x00\x00\x6c\x12\x7e\x90\x6e\x00"
+"\x3e\x50\x90\x9c\xf0\x90\x9e\x00\x60\x90\x00\x60\x90\x90\x60\x00"
+"\x90\x00\x00\x60\x90\x90\x60\x00\x40\x20\x00\x60\x90\x90\x60\x00"
+"\x40\xa0\x00\xa0\xa0\xa0\x50\x00\x40\x20\x00\xa0\xa0\xa0\x50\x00"
+"\x90\x00\x90\x90\xb0\x50\x10\xe0\x50\x00\x70\x88\x88\x88\x70\x00"
+"\x50\x00\x88\x88\x88\x88\x70\x00\x20\x20\x78\x80\x80\x78\x20\x20"
+"\x18\x24\x20\xf8\x20\xe2\x5c\x00\x88\x50\x20\xf8\x20\xf8\x20\x00"
+"\xc0\xa0\xa0\xc8\x9c\x88\x88\x8c\x18\x20\x20\xf8\x20\x20\x20\x40"
+"\x10\x20\x70\x08\x78\x88\x78\x00\x10\x20\x00\x60\x20\x20\x70\x00"
+"\x20\x40\x00\x60\x90\x90\x60\x00\x20\x40\x00\x90\x90\x90\x68\x00"
+"\x50\xa0\x00\xa0\xd0\x90\x90\x00\x28\x50\x00\xc8\xa8\x98\x88\x00"
+"\x00\x70\x08\x78\x88\x78\x00\xf8\x00\x60\x90\x90\x90\x60\x00\xf0"
+"\x20\x00\x20\x40\x80\x88\x70\x00\x00\x00\x00\xf8\x80\x80\x00\x00"
+"\x00\x00\x00\xf8\x08\x08\x00\x00\x84\x88\x90\xa8\x54\x84\x08\x1c"
+"\x84\x88\x90\xa8\x58\xa8\x3c\x08\x20\x00\x00\x20\x20\x20\x20\x00"
+"\x00\x00\x24\x48\x90\x48\x24\x00\x00\x00\x90\x48\x24\x48\x90\x00"
+"\x28\x50\x20\x50\x88\xf8\x88\x00\x28\x50\x70\x08\x78\x88\x78\x00"
+"\x28\x50\x00\x70\x20\x20\x70\x00\x28\x50\x00\x20\x20\x20\x70\x00"
+"\x28\x50\x00\x70\x88\x88\x70\x00\x50\xa0\x00\x60\x90\x90\x60\x00"
+"\x28\x50\x00\x88\x88\x88\x70\x00\x50\xa0\x00\xa0\xa0\xa0\x50\x00"
+"\xfc\x48\x48\x48\xe8\x08\x50\x20\x00\x50\x00\x50\x50\x50\x10\x20"
+"\xc0\x44\xc8\x54\xec\x54\x9e\x04\x10\xa8\x40\x00\x00\x00\x00\x00"
+"\x00\x20\x50\x88\x50\x20\x00\x00\x88\x10\x20\x40\x80\x28\x00\x00"
+"\x7c\xa8\xa8\x68\x28\x28\x28\x00\x38\x40\x30\x48\x48\x30\x08\x70"
+"\x00\x00\x00\x00\x00\x00\xff\xff\xf0\xf0\xf0\xf0\x0f\x0f\x0f\x0f"
+"\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00"
+"\x00\x00\x00\x3c\x3c\x00\x00\x00\xff\xff\xff\xff\xff\xff\x00\x00"
+"\xc0\xc0\xc0\xc0\xc0\xc0\xc0\xc0\x0f\x0f\x0f\x0f\xf0\xf0\xf0\xf0"
+"\xfc\xfc\xfc\xfc\xfc\xfc\xfc\xfc\x03\x03\x03\x03\x03\x03\x03\x03"
+"\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x3f\x11\x22\x44\x88\x11\x22\x44\x88"
+"\x88\x44\x22\x11\x88\x44\x22\x11\xfe\x7c\x38\x10\x00\x00\x00\x00"
+"\x00\x00\x00\x00\x10\x38\x7c\xfe\x80\xc0\xe0\xf0\xe0\xc0\x80\x00"
+"\x01\x03\x07\x0f\x07\x03\x01\x00\xff\x7e\x3c\x18\x18\x3c\x7e\xff"
+"\x81\xc3\xe7\xff\xff\xe7\xc3\x81\xf0\xf0\xf0\xf0\x00\x00\x00\x00"
+"\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x00\x00\x00\x00"
+"\x00\x00\x00\x00\xf0\xf0\xf0\xf0\x33\x33\xcc\xcc\x33\x33\xcc\xcc"
+"\x00\x20\x20\x50\x50\x88\xf8\x00\x20\x20\x70\x20\x70\x20\x20\x00"
+"\x00\x00\x00\x50\x88\xa8\x50\x00\xff\xff\xff\xff\xff\xff\xff\xff"
+"\x00\x00\x00\x00\xff\xff\xff\xff\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0"
+"\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\xff\xff\xff\xff\x00\x00\x00\x00"
+"\x00\x00\x68\x90\x90\x90\x68\x00\x30\x48\x48\x70\x48\x48\x70\xc0"
+"\xf8\x88\x80\x80\x80\x80\x80\x00\xf8\x50\x50\x50\x50\x50\x98\x00"
+"\xf8\x88\x40\x20\x40\x88\xf8\x00\x00\x00\x78\x90\x90\x90\x60\x00"
+"\x00\x50\x50\x50\x50\x68\x80\x80\x00\x50\xa0\x20\x20\x20\x20\x00"
+"\xf8\x20\x70\xa8\xa8\x70\x20\xf8\x20\x50\x88\xf8\x88\x50\x20\x00"
+"\x70\x88\x88\x88\x50\x50\xd8\x00\x30\x40\x40\x20\x50\x50\x50\x20"
+"\x00\x00\x00\x50\xa8\xa8\x50\x00\x08\x70\xa8\xa8\xa8\x70\x80\x00"
+"\x38\x40\x80\xf8\x80\x40\x38\x00\x70\x88\x88\x88\x88\x88\x88\x00"
+"\x00\xf8\x00\xf8\x00\xf8\x00\x00\x20\x20\xf8\x20\x20\x00\xf8\x00"
+"\xc0\x30\x08\x30\xc0\x00\xf8\x00\x18\x60\x80\x60\x18\x00\xf8\x00"
+"\x10\x28\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\xa0\x40"
+"\x00\x20\x00\xf8\x00\x20\x00\x00\x00\x50\xa0\x00\x50\xa0\x00\x00"
+"\x00\x18\x24\x24\x18\x00\x00\x00\x00\x30\x78\x78\x30\x00\x00\x00"
+"\x00\x00\x00\x00\x30\x00\x00\x00\x3e\x20\x20\x20\xa0\x60\x20\x00"
+"\xa0\x50\x50\x50\x00\x00\x00\x00\x40\xa0\x20\x40\xe0\x00\x00\x00"
+"\x00\x38\x38\x38\x38\x38\x38\x00\x00\x00\x00\x00\x00\x00\x00";
+
+
+static void draw_plot(int x, int y, u32 color)
+{
+	u8 *base = (u8*)((SCREEN_TOP_H-y-1)*3 +x*3*SCREEN_TOP_H);
+	u8 *p1 = base + FB_TOP_LEFT1;
+	u8 *p2 = base + FB_TOP_LEFT2;
+	u8 *p3 = base + FB_TOP_RIGHT1;
+	u8 *p4 = base + FB_TOP_RIGHT2;
+	p1[0] = p2[0] = p3[0] = p4[0] = color & 0xFF;
+	p1[1] = p2[1] = p3[1] =	p4[1] = (color>>8) & 0xFF;
+	p1[2] = p2[2] = p3[2] =	p4[2] = (color>>16) & 0xFF;
+}
+
+static int font_draw_char(int x, int y, u32 color, char c)
+{
+	u8 *font = (u8*)(msx_font + c * 8);
+	int i, j;
+	for (i = 0; i < 8; ++i) {
+		for (j = 0; j < 8; ++j) {
+			draw_plot(x+j, y+i, BLACK);
+			if ((*font & (128 >> j))) draw_plot(x+j, y+i, color);
+		}
+		++font;
+	}
+	return x+8;
+}
+
+unsigned long cns_x, cns_y;
+
+static void putc(char c)
+{
+	if (c == '\n') {
+		cns_y += 10;
+	} else if (c == '\r'){
+		cns_x = 8;
+	} else if (c == '\t'){
+		cns_x += 8*4;
+	} else {
+		font_draw_char(cns_x, cns_y, WHITE, c);
+		cns_x += 8;
+	}
+	if (cns_x > (SCREEN_TOP_W-8)) cns_x = 8;
+	if (cns_y > (SCREEN_TOP_H-10)) cns_y = 8;
+}
+
+static void flush(void)
+{
+}
+
+static inline void arch_decomp_setup(void)
+{
+	cns_x = 8;
+	cns_y = 8;
+}
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/nintendo3ds_ctr.c linux-3ds/arch/arm/mach-nintendo3ds/nintendo3ds_ctr.c
--- linux-5.4.12/arch/arm/mach-nintendo3ds/nintendo3ds_ctr.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/nintendo3ds_ctr.c	2020-01-17 14:59:23.565817509 -0300
@@ -0,0 +1,51 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irqchip/arm-gic.h>
+#include <linux/platform_device.h>
+
+#include <linux/clk-provider.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/smp_twd.h>
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <mach/bottom_lcd.h>
+
+static void __init nintendo3ds_pdn_set_spi_new(void)
+{
+	void __iomem *pdn_spi_cnt;
+
+	pdn_spi_cnt = ioremap(NINTENDO3DS_REG_PDN_SPI_CNT, 4);
+	iowrite16(ioread16(pdn_spi_cnt) | 7, pdn_spi_cnt);
+	iounmap(pdn_spi_cnt);
+}
+
+static void __init nintendo3ds_ctr_dt_init_machine(void)
+{
+	printk("nintendo3ds_ctr_dt_init_machine\n");
+
+	nintendo3ds_bottom_setup_fb();
+	nintendo3ds_bottom_lcd_map_fb();
+	nintendo3ds_pdn_set_spi_new();
+
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+}
+
+static const char __initconst *nintendo3ds_ctr_dt_platform_compat[] = {
+	"nintendo3ds,ctr",
+	NULL,
+};
+
+DT_MACHINE_START(NINTENDO3DS_DT, "Nintendo 3DS (CTR) (Device Tree)")
+	.init_machine	= nintendo3ds_ctr_dt_init_machine,
+	.dt_compat	= nintendo3ds_ctr_dt_platform_compat,
+MACHINE_END
diff -Naur '--exclude=certs' linux-5.4.12/arch/arm/mach-nintendo3ds/platsmp.c linux-3ds/arch/arm/mach-nintendo3ds/platsmp.c
--- linux-5.4.12/arch/arm/mach-nintendo3ds/platsmp.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/arch/arm/mach-nintendo3ds/platsmp.c	2020-01-17 11:21:00.039457297 -0300
@@ -0,0 +1,67 @@
+/*
+ * SMP support for the Nintendo 3DS
+ *
+ * Copyright (C) 2016 Sergi Granell
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/memory.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/smp.h>
+
+#include <asm/smp_scu.h>
+
+#include <mach/platsmp.h>
+
+/*
+ * CPU1 waits for IPI Interrupt 0x1,
+ * 0x1FFFFFDC is where it expects the entrypoint.
+ */
+
+#define SECONDARY_STARTUP_ADDR	0x1FFFFFDC
+#define SCU_BASE_ADDR		0x17E00000
+
+extern void smp_cross_call(const struct cpumask *target, unsigned int ipinr);
+
+static int nintendo3ds_smp_boot_secondary(unsigned int cpu,
+				    struct task_struct *idle)
+{
+	//arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+	smp_cross_call(cpumask_of(cpu), cpu);
+
+	return 0;
+}
+
+static void nintendo3ds_smp_prepare_cpus(unsigned int max_cpus)
+{
+	void __iomem *scu_base;
+	void __iomem *boot_addr;
+
+	scu_base = ioremap(SCU_BASE_ADDR, SZ_256);
+	scu_enable(scu_base);
+	iounmap(scu_base);
+
+	boot_addr = ioremap((phys_addr_t)SECONDARY_STARTUP_ADDR,
+			       sizeof(phys_addr_t));
+
+	/* Set CPU boot address */
+	writel(virt_to_phys(nintendo3ds_secondary_startup),
+		boot_addr);
+
+	iounmap(boot_addr);
+}
+
+static const struct smp_operations nintendo3ds_smp_ops __initconst = {
+	.smp_prepare_cpus	= nintendo3ds_smp_prepare_cpus,
+	.smp_boot_secondary	= nintendo3ds_smp_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(nintendo3ds_smp, "nintendo3ds,smp", &nintendo3ds_smp_ops);
diff -Naur '--exclude=certs' linux-5.4.12/copy_3ds.sh linux-3ds/copy_3ds.sh
--- linux-5.4.12/copy_3ds.sh	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/copy_3ds.sh	2020-01-17 09:02:23.771004133 -0300
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+lftp 192.168.1.65:5000 << EOF
+
+put arch/arm/boot/zImage -o /linux/zImage
+put arch/arm/boot/dts/nintendo3ds_ctr.dtb -o /linux/nintendo3ds_ctr.dtb
+put ../arm9linuxfw/arm9linuxfw.bin -o /linux/arm9linuxfw.bin
+
+bye
+EOF
diff -Naur '--exclude=certs' linux-5.4.12/diff_3ds.sh linux-3ds/diff_3ds.sh
--- linux-5.4.12/diff_3ds.sh	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/diff_3ds.sh	2020-02-21 10:45:03.080858180 -0300
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+make clean
+make ARCH=arm clean
+
+rm usr/initramfs_data.cpio*
+cp .config arch/arm/configs/nintendo3ds_defconfig
+
+make distclean
+make ARCH=arm distclean
+
+cd ../
+diff -Naur --exclude="certs" linux-5.4.12/ linux-3ds/ > linux-3ds.patch
+cd linux-3ds/
+
+cp arch/arm/configs/nintendo3ds_defconfig .config
diff -Naur '--exclude=certs' linux-5.4.12/drivers/mtd/spi-nor/spi-nor.c linux-3ds/drivers/mtd/spi-nor/spi-nor.c
--- linux-5.4.12/drivers/mtd/spi-nor/spi-nor.c	2020-01-14 16:08:40.000000000 -0300
+++ linux-3ds/drivers/mtd/spi-nor/spi-nor.c	2020-01-17 09:02:23.774005633 -0300
@@ -2402,6 +2402,9 @@
 	{ "m25p64",  INFO(0x202017,  0,  64 * 1024, 128, 0) },
 	{ "m25p128", INFO(0x202018,  0, 256 * 1024,  64, 0) },
 
+	/* HACKED ON TOP FOR NINTENDO 3DS - NEED TO FIND THE CORRECT INFO */
+	{ "m25something", INFO(0x20580C, 0, 64 * 1024, 2, 0)},
+
 	{ "m25p05-nonjedec",  INFO(0, 0,  32 * 1024,   2, 0) },
 	{ "m25p10-nonjedec",  INFO(0, 0,  32 * 1024,   4, 0) },
 	{ "m25p20-nonjedec",  INFO(0, 0,  64 * 1024,   4, 0) },
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/Kconfig linux-3ds/drivers/platform/Kconfig
--- linux-5.4.12/drivers/platform/Kconfig	2020-01-14 16:08:40.000000000 -0300
+++ linux-3ds/drivers/platform/Kconfig	2020-01-17 09:02:23.775006133 -0300
@@ -6,6 +6,10 @@
 source "drivers/platform/mips/Kconfig"
 endif
 
+if ARM
+source "drivers/platform/nintendo3ds/Kconfig"
+endif
+
 source "drivers/platform/goldfish/Kconfig"
 
 source "drivers/platform/chrome/Kconfig"
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/Makefile linux-3ds/drivers/platform/Makefile
--- linux-5.4.12/drivers/platform/Makefile	2020-01-14 16:08:40.000000000 -0300
+++ linux-3ds/drivers/platform/Makefile	2020-01-17 09:02:23.776006633 -0300
@@ -9,3 +9,4 @@
 obj-$(CONFIG_OLPC_EC)		+= olpc/
 obj-$(CONFIG_GOLDFISH)		+= goldfish/
 obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
+obj-$(CONFIG_ARCH_NINTENDO3DS)	+= nintendo3ds/
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/Kconfig linux-3ds/drivers/platform/nintendo3ds/Kconfig
--- linux-5.4.12/drivers/platform/nintendo3ds/Kconfig	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/Kconfig	2020-01-29 15:33:36.176200156 -0300
@@ -0,0 +1,122 @@
+#
+# Nintendo 3DS Specific Drivers
+#
+
+menuconfig NINTENDO3DS_PLATFORM_DEVICES
+	bool "Nintendo 3DS specific device drivers"
+	depends on ARCH_NINTENDO3DS
+	default y
+	help
+	  Say Y here to get to use specific device drivers for the Nintendo 3DS
+	  port.
+
+	  It's highly recommended to enable all of them as built-in.
+
+
+if NINTENDO3DS_PLATFORM_DEVICES
+
+config NINTENDO3DS_HID
+	tristate "Nintendo 3DS HID Input Driver"
+	select INPUT_POLLDEV
+	default y
+	help
+	  Say Y here to enable the face buttons and shoulder
+	  triggers as input devices.
+
+
+
+config NINTENDO3DS_SPI
+	tristate "Nintendo 3DS SPI"
+	depends on SPI_MASTER
+	default y
+	help
+	  SPI device driver (master).
+
+config NINTENDO3DS_CODEC
+	tristate "Nintendo 3DS CODEC driver"
+	depends on NINTENDO3DS_SPI
+	select INPUT_POLLDEV
+	default y
+	help
+	  Touchscreen and Circle Pad device driver.
+
+
+
+config NINTENDO3DS_PXI
+	tristate "Nintendo 3DS PXI support"
+	default y
+	select VIRTIO
+	help
+	  PXI device driver interface (master).
+
+
+config NINTENDO3DS_I2C
+	tristate "Nintendo 3DS I2C bus support"
+	select I2C
+	select I2C_ALGOBIT
+	default y
+	help
+	  I2C device driver.
+
+config NINTENDO3DS_MCU
+	tristate "Nintendo 3DS MCU"
+	depends on NINTENDO3DS_I2C
+	select MFD_CORE
+	default y
+	help
+	  Microcontroller interface device driver.
+
+config NINTENDO3DS_RTC
+	tristate "Nintendo 3DS RTC driver"
+	depends on NINTENDO3DS_MCU
+	select RTC_CLASS
+	default y
+	help
+	  Real time clock device driver.
+
+config NINTENDO3DS_LEDS
+	tristate "Nintendo 3DS LED driver"
+	depends on NINTENDO3DS_MCU
+	select NEW_LEDS
+	select LEDS_CLASS
+	default y
+	help
+	  Controller for the various LEDs.
+
+config NINTENDO3DS_RESET
+	tristate "Nintendo 3DS reboot/poweroff driver"
+	depends on NINTENDO3DS_MCU
+	select POWER_RESET
+	default y
+	help
+	  Reboot and poweroff device driver.
+
+config NINTENDO3DS_MCUHID
+	tristate "Nintendo 3DS MCU HID driver"
+	depends on NINTENDO3DS_MCU
+	select INPUT
+	default y
+	help
+	  Driver for extra buttons in the system
+	  (HOME, POWER, Wireless switch and lid state).
+
+config NINTENDO3DS_CHARGER
+	tristate "Nintendo 3DS battery and AC driver"
+	depends on NINTENDO3DS_MCU
+	select POWER_SUPPLY
+	default y
+	help
+	  Battery and AC charger status device driver.
+
+
+
+config NINTENDO3DS_BACKLIGHT
+	tristate "Nintendo 3DS panel backlight driver"
+	select BACKLIGHT_LCD_SUPPORT
+	select LCD_CLASS_DEVICE
+	default y
+	help
+	  LCD panel backlight control device driver.
+
+
+endif # NINTENDO3DS_PLATFORM_DEVICES
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/Makefile linux-3ds/drivers/platform/nintendo3ds/Makefile
--- linux-5.4.12/drivers/platform/nintendo3ds/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/Makefile	2020-01-17 09:14:39.728683421 -0300
@@ -0,0 +1,16 @@
+obj-$(CONFIG_NINTENDO3DS_HID)	+= nintendo3ds_input.o
+
+obj-$(CONFIG_NINTENDO3DS_SPI)	+= nintendo3ds_spi.o
+obj-$(CONFIG_NINTENDO3DS_CODEC)	+= nintendo3ds_codec.o
+
+obj-$(CONFIG_NINTENDO3DS_PXI)	+= nintendo3ds_pxi.o
+
+obj-$(CONFIG_NINTENDO3DS_I2C)	+= nintendo3ds_i2c.o
+obj-$(CONFIG_NINTENDO3DS_MCU)	+= nintendo3ds_mcu.o
+obj-$(CONFIG_NINTENDO3DS_RTC)	+= nintendo3ds_rtc.o
+obj-$(CONFIG_NINTENDO3DS_LEDS)	+= nintendo3ds_leds.o
+obj-$(CONFIG_NINTENDO3DS_RESET)	+= nintendo3ds_reset.o
+obj-$(CONFIG_NINTENDO3DS_MCUHID)	+= nintendo3ds_mcuhid.o
+obj-$(CONFIG_NINTENDO3DS_CHARGER)	+= nintendo3ds_charger.o
+
+obj-$(CONFIG_NINTENDO3DS_BACKLIGHT)	+= nintendo3ds_backlight.o
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_backlight.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_backlight.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_backlight.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_backlight.c	2020-01-17 09:02:23.778007633 -0300
@@ -0,0 +1,99 @@
+/*
+ *  nintendo3ds_backlight.c
+ *
+ *  Copyright (C) 2018 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/backlight.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-backlight"
+
+/* experimentally determined, could go higher but this is high enough */
+#define N3DS_BL_MAX (192)
+
+static int nintendo3ds_backlight_update_status(struct backlight_device *bd)
+{
+	char __iomem *io = bl_get_data(bd);
+	int intensity = bd->props.brightness;
+
+	iowrite32(intensity, io + 0x240);
+	iowrite32(intensity, io + 0xA40);
+	return 0;
+}
+
+static int nintendo3ds_backlight_get_brightness(struct backlight_device *bd)
+{
+	char __iomem *io = bl_get_data(bd);
+	return ioread32(io + 0x240);
+}
+
+static const struct backlight_ops nintendo3ds_backlight_ops = {
+	.update_status = nintendo3ds_backlight_update_status,
+	.get_brightness = nintendo3ds_backlight_get_brightness,
+};
+
+static int nintendo3ds_backlight_probe(struct platform_device *pdev)
+{
+	char __iomem *iomem;
+	struct resource *mem_res;
+	struct backlight_properties props;
+	struct backlight_device *backlight;
+
+	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(mem_res))
+		return PTR_ERR(mem_res);
+
+	iomem = devm_ioremap_resource(&pdev->dev, mem_res);
+	if (IS_ERR(iomem))
+		return PTR_ERR(iomem);
+
+	memset(&props, 0, sizeof(props));
+	props.type = BACKLIGHT_RAW;
+	props.max_brightness = N3DS_BL_MAX;
+	backlight = devm_backlight_device_register(&pdev->dev, DRIVER_NAME,
+					&pdev->dev, iomem, &nintendo3ds_backlight_ops, &props);
+	if (IS_ERR(backlight)) {
+		dev_err(&pdev->dev, "failed to register backlight");
+		return PTR_ERR(backlight);
+	}
+
+	platform_set_drvdata(pdev, backlight);
+	return 0;
+}
+
+static int nintendo3ds_backlight_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_backlight_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_backlight_of_match);
+
+static struct platform_driver nintendo3ds_backlight_driver = {
+	.probe = nintendo3ds_backlight_probe,
+	.remove = nintendo3ds_backlight_remove,
+
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(nintendo3ds_backlight_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_backlight_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nintendo 3DS backlight driver");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_charger.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_charger.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_charger.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_charger.c	2020-01-17 09:02:23.780008633 -0300
@@ -0,0 +1,152 @@
+/*
+ *  nintendo3ds_charger.c
+ *
+ *  Copyright (C) 2018 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/miscdevice.h>
+#include <linux/power_supply.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-charger"
+
+#define CAPACITY_REGISTER 0x0B
+#define CHRGSTAT_REGISTER 0x0F
+
+static int battery_getprop(struct power_supply *psy,
+        enum power_supply_property psp,
+        union power_supply_propval *val)
+{
+    unsigned int batstat, cap;
+    struct regmap *mcu_regmap = power_supply_get_drvdata(psy);
+
+    regmap_read(mcu_regmap, CAPACITY_REGISTER, &cap);
+    regmap_read(mcu_regmap, CHRGSTAT_REGISTER, &batstat);
+
+    switch(psp) {
+        case POWER_SUPPLY_PROP_ONLINE:
+            val->intval = 1;
+            break;
+
+        case POWER_SUPPLY_PROP_STATUS:
+            val->intval = (batstat & 0x10) ?
+                            ((cap >= 99) ? POWER_SUPPLY_STATUS_FULL : POWER_SUPPLY_STATUS_CHARGING)
+                            : POWER_SUPPLY_STATUS_DISCHARGING;
+            break;
+
+        case POWER_SUPPLY_PROP_TECHNOLOGY:
+            val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+            break;
+
+        case POWER_SUPPLY_PROP_CAPACITY:
+            val->intval = cap;
+            break;
+
+        default:
+            return -EINVAL;
+    }
+    return 0;
+}
+
+static int ac_getprop(struct power_supply *psy,
+        enum power_supply_property psp,
+        union power_supply_propval *val)
+{
+    unsigned int acstat;
+    struct regmap *mcu_regmap = power_supply_get_drvdata(psy);
+
+    regmap_read(mcu_regmap, CHRGSTAT_REGISTER, &acstat);
+
+    switch(psp) {
+        case POWER_SUPPLY_PROP_ONLINE:
+            val->intval = (acstat >> 4) & 1;
+            break;
+
+        default:
+            return -EINVAL;
+    }
+    return 0;
+}
+
+static enum power_supply_property battery_properties[] = {
+    POWER_SUPPLY_PROP_STATUS,
+    POWER_SUPPLY_PROP_TECHNOLOGY,
+    POWER_SUPPLY_PROP_CAPACITY,
+};
+static struct power_supply_desc battery_desc = {
+    .name = "battery",
+    .type = POWER_SUPPLY_TYPE_BATTERY,
+    .properties = battery_properties,
+    .num_properties = ARRAY_SIZE(battery_properties),
+    .get_property = battery_getprop,
+};
+
+static enum power_supply_property ac_properties[] = {
+    POWER_SUPPLY_PROP_ONLINE
+};
+static struct power_supply_desc ac_desc = {
+    .name = "ac",
+    .type = POWER_SUPPLY_TYPE_MAINS,
+    .properties = ac_properties,
+    .num_properties = ARRAY_SIZE(ac_properties),
+    .get_property = ac_getprop,
+};
+
+static int nintendo3ds_charger_probe(struct platform_device *pdev)
+{
+    struct power_supply *supply;
+    struct device *dev = &pdev->dev;
+    struct power_supply_config psy_cfg = {};
+
+    psy_cfg.drv_data = dev_get_drvdata(dev->parent);
+
+    supply = devm_power_supply_register(dev, &battery_desc, &psy_cfg);
+    if (IS_ERR(supply)) {
+        dev_warn(dev, "unable to register battery driver");
+        return PTR_ERR(supply);
+    }
+
+    supply = devm_power_supply_register(dev, &ac_desc, &psy_cfg);
+    if (IS_ERR(supply)) {
+        dev_warn(dev, "unable to register AC driver");
+        return PTR_ERR(supply);
+    }
+
+    return 0;
+}
+
+static int nintendo3ds_charger_remove(struct platform_device *pdev)
+{
+    return 0;
+}
+
+static const struct of_device_id nintendo3ds_charger_of_match[] = {
+    { .compatible = "nintendo3ds," DRIVER_NAME, },
+    {}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_charger_of_match);
+
+static struct platform_driver nintendo3ds_charger_driver = {
+    .probe = nintendo3ds_charger_probe,
+    .remove = nintendo3ds_charger_remove,
+
+    .driver = {
+        .name = DRIVER_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table = of_match_ptr(nintendo3ds_charger_of_match),
+    },
+};
+module_platform_driver(nintendo3ds_charger_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nintendo 3DS battery and AC charger driver");
+MODULE_ALIAS("mfd:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_codec.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_codec.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_codec.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_codec.c	2020-01-17 16:41:25.678194193 -0300
@@ -0,0 +1,554 @@
+/*
+ * nintendo3ds_codec.c
+ *
+ * Copyright (C) 2016 Sergi Granell (xerpi)
+ * Copyright (C) 2017 Paul LaMendola (paulguy)
+ * based on ad7879-spi.c
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <linux/input.h>
+#include <linux/input-polldev.h>
+#include <linux/spi/spi.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/jiffies.h>
+
+
+#include <linux/font.h>
+#include <asm/io.h>
+#define HIGHLIGHT_COLOR 0xFF0000
+#define COLOR_BLACK		0x000000
+#define COLOR_WHITE		0xFFFFFF
+void nintendo3ds_bottom_lcd_clear_screen(unsigned int color);
+int nintendo3ds_bottom_lcd_draw_text(const struct font_desc *font, int x, int y, unsigned int fgcolor, unsigned int bgcolor, const char *text);
+
+
+#define DRIVER_NAME	"nintendo3ds-codec"
+#define POLL_INTERVAL_DEFAULT		20
+#define MAX_12BIT			((1 << 12) - 1)
+#define CIRCLE_PAD_THRESHOLD		150
+#define CIRCLE_PAD_FACTOR		150
+
+#define VKB_ROWS (6)
+#define VKB_COLS (17)
+
+
+#define LEFT_SHIFTED  BIT(0)
+#define RIGHT_SHIFTED BIT(1)
+
+struct vkb_ctx_t {
+	const struct font_desc *font;
+	unsigned int key_locked[VKB_ROWS][VKB_COLS / sizeof(int) + 1];
+	unsigned int x_offsets[VKB_ROWS][VKB_COLS];
+	unsigned char x_sizes[VKB_ROWS][VKB_COLS];
+	unsigned char last_key;
+	bool locked_key;
+	int held_row;
+	int held_col;
+	char shifted;
+};
+
+struct nintendo3ds_codec_hid {
+	struct spi_device *spi;
+	struct input_polled_dev *polled_dev;
+	struct input_dev *input_dev;
+
+	struct vkb_ctx_t vkb;
+	unsigned long touch_jiffies;
+	bool pendown;
+};
+
+/* VKB stuff */
+
+/*
+0123456789012345678901234567890123456789
+Es 1 2 3 4 5 6 7 8 9 10 11 12 PSc SLk Bk
+` 1 2 3 4 5 6 7 8 9 0 - = BSp Ins Hom PU
+<> q w e r t y u i o p [ ]  \ Del End PD
+Cap a s d f g h j k l ; ' Ent
+LShf z x c v b n m , . / Rshf
+Ctl M Alt Space Alt M Mnu Ctl
+*/
+
+static const char *vkb_map_normal[VKB_ROWS][VKB_COLS] = {
+	{"Es", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "PSc", "SLk", "Bk"},
+	{"`", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "BSp", "Ins", "Hom", "PU"},
+	{"<>", "q", "w", "e", "r", "t", "y", "u", "i", "o", "p", "[", "]", " \\", "Del", "End", "PD"},
+	{"Cap", "a", "s", "d", "f", "g", "h", "j", "k", "l", ";", "'", "Ent", NULL, NULL, NULL, NULL},
+	{"LShf", "z", "x", "c", "v", "b", "n", "m", ",", ".", "/", "RShf", NULL, NULL, NULL, NULL, NULL},
+	{"Ctl", "M", "Alt", "Space", "Alt", "M", "Mnu", "Ctl", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
+};
+
+static const char *vkb_map_shift[VKB_ROWS][VKB_COLS] = {
+	{"Es", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "PSc", "SLk", "Bk"},
+	{"`", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "_", "+", "BSp", "Ins", "Hom", "PU"},
+	{"<>", "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P", "{", "}", " |", "Del", "End", "PD"},
+	{"Cap", "A", "S", "D", "F", "G", "H", "J", "K", "L", ":", "\"", "Ent", NULL, NULL, NULL, NULL},
+	{"LShf", "Z", "X", "C", "V", "B", "N", "M", "<", ">", "?", "RShf", NULL, NULL, NULL, NULL, NULL},
+	{"Ctl", "M", "Alt", "Space", "Alt", "M", "Mnu", "Ctl", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}
+};
+
+static const char vkb_map_keys[VKB_ROWS][VKB_COLS] = {
+	{KEY_ESC, KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10, KEY_F11, KEY_F12, KEY_SYSRQ, KEY_SCROLLLOCK, KEY_PAUSE},
+	{KEY_GRAVE, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_0, KEY_MINUS, KEY_EQUAL, KEY_BACKSPACE, KEY_INSERT, KEY_HOME, KEY_PAGEUP},
+	{KEY_TAB, KEY_Q, KEY_W, KEY_E, KEY_R, KEY_T, KEY_Y, KEY_U, KEY_I, KEY_O, KEY_P, KEY_LEFTBRACE, KEY_RIGHTBRACE, KEY_BACKSLASH, KEY_DELETE, KEY_END, KEY_PAGEDOWN},
+	{KEY_CAPSLOCK, KEY_A, KEY_S, KEY_D, KEY_F, KEY_G, KEY_H, KEY_J, KEY_K, KEY_L, KEY_SEMICOLON, KEY_COMMA, KEY_ENTER, 0, 0, 0, 0},
+	{KEY_LEFTSHIFT, KEY_Z, KEY_X, KEY_C, KEY_V, KEY_B, KEY_N, KEY_M, KEY_COMMA, KEY_DOT, KEY_SLASH, KEY_RIGHTSHIFT, 0, 0, 0, 0, 0},
+	{KEY_LEFTCTRL, KEY_LEFTMETA, KEY_LEFTALT, KEY_SPACE, KEY_RIGHTALT, KEY_RIGHTMETA, KEY_MENU, KEY_RIGHTCTRL, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+};
+
+static void vkb_draw_key(const struct vkb_ctx_t *vkb, int row, int col) {
+	unsigned int color;
+
+	if(vkb->key_locked[row][col / sizeof(int)] & BIT(col % sizeof(int)))
+		color = HIGHLIGHT_COLOR;
+	else
+		color = COLOR_WHITE;
+
+	if(vkb->shifted) {
+		if(vkb_map_shift[row][col]) {
+			if (row == 0 || row == 5 || vkb_map_normal[row][col][1] != '\0')
+				nintendo3ds_bottom_lcd_draw_text(vkb->font, vkb->x_offsets[row][col], row * vkb->font->height * 2, COLOR_BLACK, color,
+						                               vkb_map_shift[row][col]);
+			else
+				nintendo3ds_bottom_lcd_draw_text(vkb->font, vkb->x_offsets[row][col], row * vkb->font->height * 2, color, COLOR_BLACK, 
+						                               vkb_map_shift[row][col]);
+		}
+	} else {
+		if(vkb_map_normal[row][col]) {
+			if (row == 0 || row == 5 || vkb_map_normal[row][col][1] != '\0')
+				nintendo3ds_bottom_lcd_draw_text(vkb->font, vkb->x_offsets[row][col], row * vkb->font->height * 2, COLOR_BLACK, color,
+						                               vkb_map_normal[row][col]);
+			else
+				nintendo3ds_bottom_lcd_draw_text(vkb->font, vkb->x_offsets[row][col], row * vkb->font->height * 2, color, COLOR_BLACK, 
+						                               vkb_map_normal[row][col]);
+		}
+	}
+}
+
+static void vkb_draw_bottom_lcd(const struct vkb_ctx_t *vkb)
+{
+	int i, j;
+
+	for (j = 0; j < VKB_ROWS; j++) {
+		for (i = 0; i < VKB_COLS; i++) {
+			vkb_draw_key(vkb, j, i);
+		}
+	}
+}
+
+static int vkb_init(struct vkb_ctx_t *vkb)
+{
+	int x, i, j;
+
+	vkb->font = get_default_font(320, 240, -1, -1);
+	vkb->last_key = 0;
+	vkb->locked_key = false;
+	vkb->shifted = false;
+
+	for(j = 0; j < VKB_ROWS; j++) {
+		x = 0;
+		for(i = 0; i < VKB_COLS; i++) {
+			if (!vkb_map_normal[j][i]) {
+				vkb->x_sizes[j][i] = 0;
+				vkb->x_offsets[j][i] = 0;
+				continue;
+			}
+			vkb->x_offsets[j][i] = x;
+			vkb->x_sizes[j][i] = (strlen(vkb_map_normal[j][i]) + 1) * vkb->font->width;
+			x += vkb->x_sizes[j][i];
+		}
+	}
+
+	for(j = 0; j < VKB_ROWS; j++) {
+		for(i = 0; i < VKB_COLS / sizeof(int) + 1; i++) {
+			vkb->key_locked[j][i] = 0;
+		}
+	}
+
+	nintendo3ds_bottom_lcd_clear_screen(COLOR_BLACK);
+	vkb_draw_bottom_lcd(vkb);
+
+	return 0;
+}
+/* End VKB stuff */
+
+/* SPI stuff */
+static int spi_write_2(struct spi_device *spi,
+		       u8 *tx_buf0, u8 tx_len0,
+		       u8 *tx_buf1, u8 tx_len1)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers[2];
+
+	memset(xfers, 0, sizeof(xfers));
+
+	xfers[0].tx_buf = tx_buf0;
+	xfers[0].len = tx_len0;
+
+	xfers[1].tx_buf = tx_buf1;
+	xfers[1].len = tx_len1;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	return spi_sync(spi, &msg);
+}
+
+static int spi_write_read(struct spi_device *spi,
+			  u8 *tx_buf, u8 tx_len,
+			  u8 *rx_buf, u8 rx_len)
+{
+	struct spi_message msg;
+	struct spi_transfer xfers[2];
+
+	memset(xfers, 0, sizeof(xfers));
+
+	xfers[0].tx_buf = tx_buf;
+	xfers[0].len = tx_len;
+
+	xfers[1].rx_buf = rx_buf;
+	xfers[1].len = rx_len;
+
+	spi_message_init(&msg);
+
+	spi_message_add_tail(&xfers[0], &msg);
+	spi_message_add_tail(&xfers[1], &msg);
+
+	return spi_sync(spi, &msg);
+}
+
+static void spi_reg_select(struct spi_device *spi, u8 reg)
+{
+	u8 buffer1[4];
+	u8 buffer2[0x40];
+
+	buffer1[0] = 0;
+	buffer2[0] = reg;
+
+	spi_write_2(spi, buffer1, 1, buffer2, 1);
+}
+
+static u8 spi_reg_read_offset(struct spi_device *spi, u8 offset)
+{
+	u8 buffer_wr[8];
+	u8 buffer_rd[0x40];
+
+	buffer_wr[0] = 1 | (offset << 1);
+
+	spi_write_read(spi, buffer_wr, 1, buffer_rd, 1);
+
+	return buffer_rd[0];
+}
+
+static void spi_reg_write_offset(struct spi_device *spi, u8 reg, u8 val)
+{
+	u8 buffer1[8];
+	u8 buffer2[0x40];
+
+	buffer1[0] = (reg << 1); // Write
+	buffer2[0] = val;
+
+	spi_write_2(spi, buffer1, 1, buffer2, 1);
+}
+
+static void spi_reg_read_buffer(struct spi_device *spi,
+			       u8 offset, void *buffer, u8 size)
+{
+	u8 buffer_wr[0x10];
+
+	buffer_wr[0] = 1 | (offset << 1);
+
+	spi_write_read(spi, buffer_wr, 1, buffer, size);
+}
+
+static void spi_reg_mask_offset(struct spi_device *spi, u8 offset, u8 mask0, u8 mask1)
+{
+	u8 buffer1[4];
+	u8 buffer2[0x40];
+
+	buffer1[0] = 1 | (offset << 1);
+
+	spi_write_read(spi, buffer1, 1, buffer2, 1);
+
+	buffer1[0] = offset << 1;
+	buffer2[0] = (buffer2[0] & ~mask1) | (mask0 & mask1);
+
+	spi_write_2(spi, buffer1, 1, buffer2, 1);
+}
+
+static void spi_codec_hid_initialize(struct spi_device *spi)
+{
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x24, 0x98);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x26, 0x00);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x25, 0x43);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x24, 0x18);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x17, 0x43);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x19, 0x69);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x1B, 0x80);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x27, 0x11);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x26, 0xEC);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x24, 0x18);
+	spi_reg_select(spi, 0x67);
+	spi_reg_write_offset(spi, 0x25, 0x53);
+
+	spi_reg_select(spi, 0x67);
+	spi_reg_mask_offset(spi, 0x26, 0x80, 0x80);
+	spi_reg_select(spi, 0x67);
+	spi_reg_mask_offset(spi, 0x24, 0x00, 0x80);
+	spi_reg_select(spi, 0x67);
+	spi_reg_mask_offset(spi, 0x25, 0x10, 0x3C);
+}
+
+static void spi_codec_hid_request_data(struct spi_device *spi, u8 *buffer)
+{
+	spi_reg_select(spi, 0x67);
+	spi_reg_read_offset(spi, 0x26);
+	spi_reg_select(spi, 0xFB);
+	spi_reg_read_buffer(spi, 1, buffer, 0x34);
+}
+/* End SPI stuff */
+
+static void nintendo3ds_codec_hid_open(struct input_polled_dev *dev)
+{
+}
+
+static void nintendo3ds_codec_hid_close(struct input_polled_dev *dev)
+{
+}
+
+static void nintendo3ds_codec_hid_poll(struct input_polled_dev *polled_dev)
+{
+	struct nintendo3ds_codec_hid *codec_hid = polled_dev->private;
+	struct input_dev *input_dev = codec_hid->input_dev;
+	struct vkb_ctx_t *vkb = &codec_hid->vkb;
+
+	u8 raw_data[0x40] __attribute__((aligned(sizeof(u16))));
+	bool pendown;
+	u16 raw_touch_x;
+	u16 raw_touch_y;
+	u16 screen_touch_x;
+	u16 screen_touch_y;
+	s16 raw_circlepad_x;
+	s16 raw_circlepad_y;
+	bool sync = false;
+	int i, j;
+
+	spi_codec_hid_request_data(codec_hid->spi, raw_data);
+
+	raw_circlepad_x =
+		(s16)le16_to_cpu(((raw_data[0x24] << 8) | raw_data[0x25]) & 0xFFF) - 2048;
+	raw_circlepad_y =
+		(s16)le16_to_cpu(((raw_data[0x14] << 8) | raw_data[0x15]) & 0xFFF) - 2048;
+
+	if (abs(raw_circlepad_x) > CIRCLE_PAD_THRESHOLD) {
+		input_report_rel(input_dev, REL_X,
+				 -raw_circlepad_x / CIRCLE_PAD_FACTOR);
+		sync = true;
+	}
+
+	if (abs(raw_circlepad_y) > CIRCLE_PAD_THRESHOLD) {
+		input_report_rel(input_dev, REL_Y,
+				 -raw_circlepad_y / CIRCLE_PAD_FACTOR);
+		sync = true;
+	}
+
+	pendown = !(raw_data[0] & BIT(4));
+
+	if (pendown) {
+		if(!codec_hid->pendown) {
+			raw_touch_x = le16_to_cpu((raw_data[0]  << 8) | raw_data[1]);
+			raw_touch_y = le16_to_cpu((raw_data[10] << 8) | raw_data[11]);
+
+			screen_touch_x = (u16)((u32)raw_touch_x * 320 / MAX_12BIT);
+			screen_touch_y = (u16)((u32)raw_touch_y * 240 / MAX_12BIT);
+
+			for(j = 0; j < VKB_ROWS; j++) {
+				for(i = 0; i < VKB_COLS; i++) {
+					if(vkb->x_sizes[j][i] > 0 &&
+					   screen_touch_x >= vkb->x_offsets[j][i] &&
+					   screen_touch_x < vkb->x_offsets[j][i] + vkb->x_sizes[j][i] &&
+					   screen_touch_y >= j * vkb->font->height * 2 &&
+					   screen_touch_y < (j + 1) * vkb->font->height * 2) {
+						codec_hid->pendown = true;
+
+						codec_hid->touch_jiffies = jiffies;
+
+						vkb->last_key = vkb_map_keys[j][i];
+						if(vkb->key_locked[j][i / sizeof(int)] & BIT(i % sizeof(int))) {
+							vkb->key_locked[j][i / sizeof(int)] &= ~BIT(i % sizeof(int));
+							input_report_key(input_dev, vkb->last_key, 0);
+							if(vkb->last_key == KEY_LEFTSHIFT)
+								vkb->shifted &= ~LEFT_SHIFTED;
+							else if(vkb->last_key == KEY_RIGHTSHIFT)
+								vkb->shifted &= ~RIGHT_SHIFTED;
+
+							if(vkb->shifted == 0)
+								vkb_draw_bottom_lcd(vkb);
+
+							vkb->locked_key = true;
+
+							vkb_draw_key(vkb, j, i);
+						} else {
+							input_report_key(input_dev, vkb->last_key, 1);
+						}
+
+						vkb->held_row = j;
+						vkb->held_col = i;
+
+						sync = true;
+						i = VKB_COLS;
+						j = VKB_ROWS;
+					}
+				}
+			}
+		} else {
+			if(!vkb->locked_key && time_is_before_jiffies(codec_hid->touch_jiffies + msecs_to_jiffies(500))) {
+				vkb->key_locked[vkb->held_row][vkb->held_col / sizeof(int)] |= BIT(vkb->held_col % sizeof(int));
+				vkb->locked_key = true;
+
+				if(vkb_map_keys[vkb->held_row][vkb->held_col] == KEY_LEFTSHIFT)
+					vkb->shifted |= LEFT_SHIFTED;
+				else if(vkb_map_keys[vkb->held_row][vkb->held_col] == KEY_RIGHTSHIFT)
+					vkb->shifted |= RIGHT_SHIFTED;
+
+				if(vkb->shifted != 0)
+					vkb_draw_bottom_lcd(vkb);
+
+				vkb_draw_key(vkb, vkb->held_row, vkb->held_col);
+			}
+		}
+	} else {
+		codec_hid->pendown = false;
+
+		if(vkb->locked_key) {
+			vkb->locked_key = false;
+		} else {
+			if(vkb->last_key) {
+				input_report_key(input_dev, vkb->last_key, 0);
+				sync = true;
+			}
+		}
+
+		vkb->last_key = 0;
+	}
+
+	if(sync)
+		input_sync(input_dev);
+}
+
+static int nintendo3ds_codec_hid_probe(struct spi_device *spi)
+{
+	struct nintendo3ds_codec_hid *codec_hid;
+	struct input_polled_dev *polled_dev;
+	struct input_dev *input_dev;
+	int err;
+	int i, j;
+
+	/* SPI circle pad and touchscreen stuff */
+	spi->bits_per_word = 8;
+	spi->mode = SPI_MODE_0;
+
+	err = spi_setup(spi);
+	if (err < 0) {
+		dev_err(&spi->dev, "spi setup error (%d)", err);
+		return err;
+	}
+
+	codec_hid = devm_kzalloc(&spi->dev, sizeof(*codec_hid), GFP_KERNEL);
+	if (IS_ERR(codec_hid)) {
+		dev_err(&spi->dev, "failed to allocate driver (%lu)", PTR_ERR(codec_hid));
+		return PTR_ERR(codec_hid);
+	}
+
+	polled_dev = devm_input_allocate_polled_device(&spi->dev);
+	if (IS_ERR(polled_dev)) {
+		dev_err(&spi->dev, "failed to allocate input device (%d)", err);
+		return PTR_ERR(polled_dev);
+	}
+
+	polled_dev->private = codec_hid;
+	polled_dev->poll = nintendo3ds_codec_hid_poll;
+	polled_dev->open = nintendo3ds_codec_hid_open;
+	polled_dev->close = nintendo3ds_codec_hid_close;
+	polled_dev->poll_interval = POLL_INTERVAL_DEFAULT;
+
+	input_dev = polled_dev->input;
+	input_dev->name = "Nintendo 3DS CODEC HID";
+	input_dev->phys = DRIVER_NAME "/input0";
+	input_dev->id.bustype = BUS_SPI;
+	input_dev->dev.parent = &spi->dev;
+
+	/* circle pad/mouse stuff */
+	set_bit(EV_REL, input_dev->evbit);
+	set_bit(REL_X, input_dev->relbit);
+	set_bit(REL_Y, input_dev->relbit);
+	set_bit(REL_WHEEL, input_dev->relbit);
+
+	/* Enable VKB keys */
+	set_bit(EV_KEY, input_dev->evbit);
+
+	for (i = 0; i < VKB_ROWS; i++) {
+		for (j = 0; j < VKB_COLS; j++) {
+			if (vkb_map_keys[i][j])
+				set_bit(vkb_map_keys[i][j], input_dev->keybit);
+		}
+	}
+
+	/* dunno what this does but the other driver sets this */
+	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
+
+	codec_hid->spi = spi;
+	codec_hid->polled_dev = polled_dev;
+	codec_hid->input_dev = polled_dev->input;
+	vkb_init(&codec_hid->vkb);
+	spi_set_drvdata(spi, codec_hid);
+
+	spi_codec_hid_initialize(spi);
+
+	err = input_register_polled_device(polled_dev);
+	if (err < 0) {
+		dev_err(&spi->dev, "failed to register input device (%d)", err);
+		return err;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id nintendo3ds_codec_hid_dt_ids[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_codec_hid_dt_ids);
+#endif
+
+static struct spi_driver nintendo3ds_codec_hid_driver = {
+	.probe = nintendo3ds_codec_hid_probe,
+
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(nintendo3ds_codec_hid_dt_ids),
+	},
+};
+module_spi_driver(nintendo3ds_codec_hid_driver);
+
+MODULE_AUTHOR("Sergi Granell <xerpi.g.12@gmail.com>");
+MODULE_DESCRIPTION("Nintendo 3DS CODEC HID driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("spi:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_i2c.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_i2c.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_i2c.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_i2c.c	2020-02-20 13:01:39.862289799 -0300
@@ -0,0 +1,241 @@
+/*
+ *  nintendo3ds_i2c.c
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  based on i2c-versatile.c and i2c-exynos5.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-i2c"
+
+/* I2C Registers */
+#define I2C_REG_DATA_OFF	0x00
+#define I2C_REG_CNT_OFF		0x01
+#define I2C_REG_CNTEX_OFF	0x02
+#define I2C_REG_SCL_OFF		0x04
+
+/* CNT Register bits */
+#define I2C_CNT_STOP	(1 << 0)
+#define I2C_CNT_START	(1 << 1)
+#define I2C_CNT_PAUSE	(1 << 2)
+#define I2C_CNT_ACK		(1 << 4)
+#define I2C_CNT_DATADIR	(1 << 5)
+#define I2C_CNT_INTEN	(1 << 6)
+#define I2C_CNT_STAT	(1 << 7)
+
+/* CNT Register data direction bit */
+#define I2C_CNT_DATADIR_WR (0 << 5)
+#define I2C_CNT_DATADIR_RD (1 << 5)
+
+/* CNT Register stat bit */
+#define I2C_CNT_STAT_START (1 << 7)
+#define I2C_CNT_STAT_BUSY  (1 << 7)
+
+#define I2C_SET_DATA_REG(base,val)	(writeb(val, base + I2C_REG_DATA_OFF))
+#define I2C_GET_DATA_REG(base)		(readb(base + I2C_REG_DATA_OFF))
+#define I2C_SET_CNT_REG(base,val)	(writeb(val, base + I2C_REG_CNT_OFF))
+#define I2C_GET_CNT_REG(base)		(readb(base + I2C_REG_CNT_OFF))
+#define I2C_SET_CNTEX_REG(base,val)	(writew(val, base + I2C_REG_CNTEX_OFF))
+#define I2C_GET_CNTEX_REG(base)		(readw(base + I2C_REG_CNTEX_OFF))
+#define I2C_SET_SCL_REG(base,val)	(writew(val, base + I2C_REG_SCL_OFF))
+#define I2C_GET_SCL_REG(base)		(readw(base + I2C_REG_SCL_OFF))
+#define I2C_BUS_IS_BUSY(base)		(I2C_GET_CNT_REG(base) & I2C_CNT_STAT_BUSY)
+
+
+struct nintendo3ds_i2c {
+	unsigned irq;
+	void __iomem *base;
+	struct i2c_adapter adap;
+};
+
+static inline void i2c_wait_busy(void __iomem *base)
+{
+	while (I2C_BUS_IS_BUSY(base))
+		;
+}
+
+static inline void i2c_select_device(void __iomem *base, u8 addr)
+{
+	i2c_wait_busy(base);
+	I2C_SET_DATA_REG(base, addr);
+	I2C_SET_CNT_REG(base, I2C_CNT_STAT_START | I2C_CNT_START);
+}
+
+static inline void i2c_select_register(void __iomem *base, u8 reg)
+{
+	i2c_wait_busy(base);
+	I2C_SET_DATA_REG(base, reg);
+	I2C_SET_CNT_REG(base, I2C_CNT_STAT_START);
+}
+
+static int nintendo3ds_i2c_xfer_msg(struct nintendo3ds_i2c *i2c,
+			struct i2c_msg *msg, bool first)
+{
+	void __iomem *base = i2c->base;
+	int i;
+
+	if (msg->len == 1 && first) {
+		/* Only select device register */
+		i2c_select_device(base, msg->addr & 0xFF);
+		i2c_select_register(base, msg->buf[0]);
+	} else if (msg->flags & I2C_M_RD) {
+		i2c_select_device(base, (msg->addr & 0xFF) | 1);
+
+		for (i = 0; i < msg->len - 1; i++) {
+			i2c_wait_busy(base);
+			I2C_SET_CNT_REG(base, I2C_CNT_STAT_START
+				| I2C_CNT_INTEN | I2C_CNT_DATADIR_RD | I2C_CNT_ACK);
+			i2c_wait_busy(base);
+			msg->buf[i] = I2C_GET_DATA_REG(base);
+		}
+		/* Last byte */
+		i2c_wait_busy(base);
+		I2C_SET_CNT_REG(base, I2C_CNT_STOP | I2C_CNT_STAT_START
+			| I2C_CNT_INTEN | I2C_CNT_DATADIR_RD);
+		i2c_wait_busy(base);
+		msg->buf[i] = I2C_GET_DATA_REG(base);
+	} else {
+		for (i = 0; i < msg->len - 1; i++) {
+			i2c_wait_busy(base);
+			I2C_SET_DATA_REG(base, msg->buf[i]);
+			i2c_wait_busy(base);
+			I2C_SET_CNT_REG(base, I2C_CNT_STAT_START
+				| I2C_CNT_INTEN | I2C_CNT_DATADIR_WR);
+		}
+		/* Last byte */
+		i2c_wait_busy(base);
+		I2C_SET_DATA_REG(base, msg->buf[i]);
+		i2c_wait_busy(base);
+		I2C_SET_CNT_REG(base, I2C_CNT_STOP | I2C_CNT_STAT_START
+			| I2C_CNT_INTEN | I2C_CNT_DATADIR_WR);
+	}
+
+	return 0;
+}
+
+static int nintendo3ds_i2c_master_xfer(struct i2c_adapter *adap,
+			struct i2c_msg *msgs, int num)
+{
+	struct nintendo3ds_i2c *i2c = adap->algo_data;
+	int i, ret = 0;
+
+	if (num == 1 && msgs[0].len > 1) {
+		// TODO: HACK - needs to be fixed
+		struct i2c_msg xfer[2];
+		xfer[0].addr = msgs->addr;
+		xfer[0].flags = 0;
+		xfer[0].len = 1;
+		xfer[0].buf = msgs->buf;
+
+		xfer[1].addr = msgs->addr;
+		xfer[1].flags = msgs->flags;
+		xfer[1].len = msgs->len - 1;
+		xfer[1].buf = (u8*)msgs->buf + 1;
+
+		return nintendo3ds_i2c_master_xfer(adap, xfer, 2);
+	}
+
+	for (i = 0; i < num; i++, msgs++) {
+		ret = nintendo3ds_i2c_xfer_msg(i2c, msgs, (i == 0));
+		if (ret < 0)
+			return ret;
+	}
+
+	return i;
+}
+
+static u32 nintendo3ds_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C;
+}
+
+static const struct i2c_algorithm nintendo3ds_i2c_algo = {
+	.master_xfer	= nintendo3ds_i2c_master_xfer,
+	.functionality	= nintendo3ds_i2c_func,
+};
+
+static int nintendo3ds_i2c_probe(struct platform_device *pdev)
+{
+	struct nintendo3ds_i2c *i2c;
+	struct resource *mem;
+	int ret;
+
+	i2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);
+	if (IS_ERR(i2c))
+		return PTR_ERR(i2c);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(mem))
+		return PTR_ERR(mem);
+
+	i2c->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(i2c->base))
+		return PTR_ERR(i2c->base);
+
+	//i2c->irq = platform_get_irq(pdev, 0);
+	//if (!i2c->irq)
+	//	return -EINVAL;
+
+	/* HW reset */
+	I2C_SET_CNT_REG(i2c->base, 0);
+	I2C_SET_CNTEX_REG(i2c->base, 2);
+	I2C_SET_SCL_REG(i2c->base, 1280);
+	i2c_wait_busy(i2c->base);
+
+	/* Setup the i2c_adapter */
+	i2c->adap.owner		= THIS_MODULE;
+	strlcpy(i2c->adap.name, "Nintendo 3DS I2C adapter", sizeof(i2c->adap.name));
+	i2c->adap.dev.parent 	= &pdev->dev;
+	i2c->adap.dev.of_node	= pdev->dev.of_node;
+	i2c->adap.algo		= &nintendo3ds_i2c_algo;
+	i2c->adap.algo_data	= i2c;
+
+	platform_set_drvdata(pdev, i2c);
+
+	ret = i2c_add_adapter(&i2c->adap);
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static int nintendo3ds_i2c_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_i2c *i2c = platform_get_drvdata(pdev);
+	i2c_del_adapter(&i2c->adap);
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_i2c_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_i2c_of_match);
+
+static struct platform_driver nintendo3ds_i2c_driver = {
+	.probe		= nintendo3ds_i2c_probe,
+	.remove		= nintendo3ds_i2c_remove,
+
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(nintendo3ds_i2c_of_match),
+	},
+};
+
+module_platform_driver(nintendo3ds_i2c_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS I2C bus driver");
+MODULE_AUTHOR("Sergi Granell, <xerpi.g.12@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_input.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_input.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_input.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_input.c	2020-01-17 09:02:23.791014132 -0300
@@ -0,0 +1,178 @@
+/*
+ *  nintendo3ds_input.c
+ *
+ *  Copyright (C) 2015 Sergi Granell
+ *  Copyright (C) 2017 Paul LaMendola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/io.h>
+#include <linux/of.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/input-polldev.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-input"
+
+/***** Buttons *****/
+
+/* We poll keys - msecs */
+#define POLL_INTERVAL_DEFAULT	20
+
+#define BUTTON_A      (1 << 0)
+#define BUTTON_B      (1 << 1)
+#define BUTTON_SELECT (1 << 2)
+#define BUTTON_START  (1 << 3)
+#define BUTTON_RIGHT  (1 << 4)
+#define BUTTON_LEFT   (1 << 5)
+#define BUTTON_UP     (1 << 6)
+#define BUTTON_DOWN   (1 << 7)
+#define BUTTON_R1     (1 << 8)
+#define BUTTON_L1     (1 << 9)
+#define BUTTON_X      (1 << 10)
+#define BUTTON_Y      (1 << 11)
+
+#define BUTTON_HELD(b, m) (~(b) & (m))
+#define BUTTON_PRESSED(b, o, m) ((~(b) & (o)) & (m))
+#define BUTTON_CHANGED(b, o, m) (((b) ^ (o)) & (m))
+
+struct nintendo3ds_input_dev {
+	struct input_polled_dev *polldev;
+	void __iomem *hid_input;
+	unsigned int old_buttons;
+};
+
+static const struct {
+	unsigned int in, out;
+} button_map[] = {
+	{BUTTON_A, BTN_A},
+	{BUTTON_B, BTN_B},
+	{BUTTON_X, BTN_X},
+	{BUTTON_Y, BTN_Y},
+	{BUTTON_L1, BTN_TL},
+	{BUTTON_R1, BTN_TR},
+	{BUTTON_START, BTN_START},
+	{BUTTON_UP, KEY_UP},
+	{BUTTON_DOWN, KEY_DOWN},
+	{BUTTON_LEFT, KEY_LEFT},
+	{BUTTON_RIGHT, KEY_RIGHT},
+};
+
+#define CHECK_BUTTON(inbutton, outbutton) \
+	if (BUTTON_CHANGED(buttons, old_buttons, inbutton)) \
+		input_report_key(idev, outbutton, BUTTON_HELD(buttons, inbutton));
+
+static void nintendo3ds_input_poll(struct input_polled_dev *pdev)
+{
+	struct nintendo3ds_input_dev *n3ds_input_dev = pdev->private;
+	struct input_dev *idev = pdev->input;
+	unsigned int buttons;
+	unsigned int old_buttons;
+	int i;
+
+	buttons = ioread32(n3ds_input_dev->hid_input);
+
+	old_buttons = n3ds_input_dev->old_buttons;
+
+	for(i = 0; i < ARRAY_SIZE(button_map); i++)
+		CHECK_BUTTON(button_map[i].in, button_map[i].out)
+
+	if(buttons != n3ds_input_dev->old_buttons) {
+		input_sync(idev);
+	}
+
+	n3ds_input_dev->old_buttons = buttons;
+}
+
+static int nintendo3ds_input_probe(struct platform_device *pdev)
+{
+	struct nintendo3ds_input_dev *n3ds_input_dev;
+	struct input_polled_dev *polldev;
+	struct input_dev *idev;
+	void __iomem *hidregs;
+	struct resource *mem;
+	int i, err;
+
+	n3ds_input_dev = devm_kzalloc(&pdev->dev, sizeof(*n3ds_input_dev), GFP_KERNEL);
+	if (IS_ERR(n3ds_input_dev))
+		return PTR_ERR(n3ds_input_dev);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(mem))
+		return PTR_ERR(mem);
+
+	hidregs = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(hidregs))
+		return PTR_ERR(hidregs);
+
+	polldev = input_allocate_polled_device();
+	if (IS_ERR(polldev))
+		return PTR_ERR(polldev);
+
+	polldev->poll = nintendo3ds_input_poll;
+	polldev->poll_interval = POLL_INTERVAL_DEFAULT;
+	polldev->private = n3ds_input_dev;
+
+	idev = polldev->input;
+	idev->name = "Nintendo 3DS input";
+	idev->phys = "nintendo3ds/input0";
+	idev->id.bustype = BUS_HOST;
+	idev->dev.parent = &pdev->dev;
+
+	set_bit(EV_KEY, idev->evbit);
+	for(i = 0; i < ARRAY_SIZE(button_map); i++)
+		set_bit(button_map[i].out, idev->keybit);
+
+	input_set_capability(idev, EV_MSC, MSC_SCAN);
+
+	n3ds_input_dev->polldev = polldev;
+	n3ds_input_dev->hid_input = hidregs;
+
+	err = input_register_polled_device(polldev);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to register device (%d)", err);
+		input_free_polled_device(polldev);
+		return err;
+	}
+
+	return 0;
+}
+
+static int nintendo3ds_input_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_input_dev *dev = platform_get_drvdata(pdev);
+	input_unregister_polled_device(dev->polldev);
+	input_free_polled_device(dev->polldev);
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_input_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_input_of_match);
+
+static struct platform_driver nintendo3ds_input_driver = {
+	.probe	= nintendo3ds_input_probe,
+	.remove	= nintendo3ds_input_remove,
+
+	.driver	= {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = nintendo3ds_input_of_match,
+	},
+};
+
+module_platform_driver(nintendo3ds_input_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS input driver");
+MODULE_AUTHOR("Sergi Granell, <xerpi.g.12@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_leds.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_leds.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_leds.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_leds.c	2020-01-17 09:02:23.791014132 -0300
@@ -0,0 +1,148 @@
+/*
+ * nintendo3ds_led.c
+ *
+ * Copyright (C) 2018 Wolfvak
+ * Information gathered from http://3dbrew.org/wiki/MCURTC:SetledsPattern
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/init.h>
+#include <linux/leds.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-leds"
+
+#define REG_LED_BRIGHTNESS	0x28
+
+#define REG_POWER_LED	0x29
+#define REG_WIFI_LED	0x2A
+#define REG_INFO_LED	0x2D
+
+struct infoled_register_state {
+	u8 delay;
+	u8 smoothing;
+	u8 loop_delay;
+	u8 unknown;
+	u8 color[3][32];
+} __packed;
+
+struct nintendo3ds_leds_state {
+	struct regmap *mcu_regmap;
+
+	struct led_classdev info_led;
+	struct led_classdev wifi_led;
+	struct led_classdev pwr_led;
+};
+
+/* currently just a white LED */
+static int infoled_set_state(struct led_classdev *led_cdev,
+							enum led_brightness brightness)
+{
+	unsigned i;
+	struct nintendo3ds_leds_state *leds;
+	struct infoled_register_state regs;
+
+	leds = container_of(led_cdev, struct nintendo3ds_leds_state, info_led);
+
+	regs.delay = 0;
+	regs.smoothing = 0;
+	regs.loop_delay = 0;
+	regs.unknown = 0;
+
+	for (i = 0; i < 32; i++) {
+		regs.color[0][i] = brightness;
+		regs.color[1][i] = brightness;
+		regs.color[2][i] = brightness;
+	}
+
+	regmap_raw_write(leds->mcu_regmap, REG_INFO_LED, &regs, sizeof(regs));
+	return 0;
+}
+
+static int mculed_setbrightness(struct regmap *mcu, int reg, u8 val)
+{ return regmap_raw_write(mcu, reg, &val, sizeof(val)); }
+
+static int wifiled_set_state(struct led_classdev *led_cdev,
+							enum led_brightness brightness)
+{
+	struct nintendo3ds_leds_state *leds =
+		container_of(led_cdev, struct nintendo3ds_leds_state, wifi_led);
+	return mculed_setbrightness(leds->mcu_regmap, REG_WIFI_LED,
+		(brightness != LED_ON) ? 1 : 0);
+}
+
+static int pwrled_set_state(struct led_classdev *led_cdev,
+							enum led_brightness brightness)
+{
+	struct nintendo3ds_leds_state *leds =
+		container_of(led_cdev, struct nintendo3ds_leds_state, pwr_led);
+	return mculed_setbrightness(leds->mcu_regmap, REG_POWER_LED,
+		(brightness != LED_ON) ? 0 : 3);
+}
+
+static int nintendo3ds_leds_probe(struct platform_device *pdev)
+{
+	int res;
+	struct nintendo3ds_leds_state *leds;
+
+	leds = devm_kzalloc(&pdev->dev, sizeof(*leds), GFP_KERNEL);
+	if (IS_ERR(leds))
+		return PTR_ERR(leds);
+
+	/* set up LEDs structure information */
+	leds->mcu_regmap = dev_get_drvdata(pdev->dev.parent);
+
+	leds->info_led.name = "nintendo3ds-infoled";
+	leds->info_led.brightness_set_blocking = infoled_set_state;
+
+	leds->wifi_led.name = "nintendo3ds-wifiled";
+	leds->wifi_led.brightness_set_blocking = wifiled_set_state;
+
+	leds->pwr_led.name = "nintendo3ds-powerled";
+	leds->pwr_led.brightness_set_blocking = pwrled_set_state;
+
+	res = devm_led_classdev_register(&pdev->dev, &leds->info_led);
+	if (res < 0)
+		return res;
+
+	res = devm_led_classdev_register(&pdev->dev, &leds->wifi_led);
+	if (res < 0)
+		return res;
+
+	return devm_led_classdev_register(&pdev->dev, &leds->pwr_led);
+}
+
+static int nintendo3ds_leds_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_leds_of_match[] = {
+    { .compatible = "nintendo3ds," DRIVER_NAME, },
+    {}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_leds_of_match);
+
+static struct platform_driver nintendo3ds_leds_driver = {
+    .probe = nintendo3ds_leds_probe,
+    .remove = nintendo3ds_leds_remove,
+
+    .driver = {
+        .name = DRIVER_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table = of_match_ptr(nintendo3ds_leds_of_match),
+    },
+};
+module_platform_driver(nintendo3ds_leds_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_DESCRIPTION("Nintendo 3DS LED driver");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_mcu.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mcu.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_mcu.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mcu.c	2020-02-02 16:51:04.422456178 -0300
@@ -0,0 +1,132 @@
+/*
+ * nintendo3ds_mcu.c
+ *
+ * Copyright (C) 2019 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/miscdevice.h>
+
+#define DRIVER_NAME "nintendo3ds-mcu"
+
+static const struct regmap_range mcu_readable[] = {
+	regmap_reg_range(0, 0x1F),
+	regmap_reg_range(0x24, 0x2C),
+	regmap_reg_range(0x2E, 0x2E),
+	regmap_reg_range(0x30, 0x3E),
+	regmap_reg_range(0x40, 0x4B),
+	regmap_reg_range(0x7F, 0x7F),
+};
+static const struct regmap_access_table mcu_readable_table = {
+	.yes_ranges = mcu_readable,
+	.n_yes_ranges = ARRAY_SIZE(mcu_readable),
+};
+
+static const struct regmap_range mcu_writeable[] = {
+	regmap_reg_range(0x10, 0x13),
+	regmap_reg_range(0x18, 0x22),
+	regmap_reg_range(0x27, 0x2D),
+	regmap_reg_range(0x2F, 0x3B),
+	regmap_reg_range(0x7F, 0x7F),
+};
+static const struct regmap_access_table mcu_writeable_table = {
+	.yes_ranges = mcu_writeable,
+	.n_yes_ranges = ARRAY_SIZE(mcu_writeable),
+};
+
+static const struct regmap_range mcu_all[] = {
+	regmap_reg_range(0, 0x7F),
+};
+static const struct regmap_access_table mcu_all_table = {
+	.yes_ranges = mcu_all,
+	.n_yes_ranges = ARRAY_SIZE(mcu_all),
+};
+
+static const struct regmap_range mcu_noinc[] = {
+	regmap_reg_range(0x2D, 0x2D),
+};
+static const struct regmap_access_table mcu_noinc_table = {
+	.yes_ranges = mcu_noinc,
+	.n_yes_ranges = ARRAY_SIZE(mcu_noinc),
+};
+
+
+static const struct regmap_config regmap_mcu_cfg = {
+	.name = "n3ds_mcuregmap",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0x7F,
+
+	.fast_io = true,
+
+	.rd_table = &mcu_readable_table,
+	.wr_table = &mcu_writeable_table,
+
+	.volatile_table = &mcu_all_table,
+	.precious_table = &mcu_all_table,
+
+	.wr_noinc_table = &mcu_noinc_table,
+	.rd_noinc_table = &mcu_noinc_table,
+};
+
+static int nintendo3ds_mcu_probe(struct i2c_client *i2c,
+					const struct i2c_device_id *id)
+{
+	struct device *dev = &i2c->dev;
+	struct regmap *mcu_regmap = devm_regmap_init_i2c(i2c, &regmap_mcu_cfg);
+	if (IS_ERR(mcu_regmap))
+		return PTR_ERR(mcu_regmap);
+
+	i2c_set_clientdata(i2c, mcu_regmap);
+	return devm_of_platform_populate(dev);
+}
+
+static const struct i2c_device_id nintendo3ds_mcu_id[] = {
+       { DRIVER_NAME, 0 },
+       { }
+};
+MODULE_DEVICE_TABLE(i2c, nintendo3ds_mcu_id);
+
+static const struct of_device_id nintendo3ds_mcu_of_match[] = {
+	{.compatible = "nintendo3ds," DRIVER_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_mcu_of_match);
+
+static struct i2c_driver nintendo3ds_mcu_driver = {
+	.probe = nintendo3ds_mcu_probe,
+	.id_table = nintendo3ds_mcu_id,
+
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = of_match_ptr(nintendo3ds_mcu_of_match),
+	},
+};
+
+static int __init nintendo3ds_mcu_init(void)
+{
+	return i2c_add_driver(&nintendo3ds_mcu_driver);
+}
+/* init early so consumer devices can complete system boot */
+subsys_initcall(nintendo3ds_mcu_init);
+
+static void __exit nintendo3ds_mcu_exit(void)
+{
+	i2c_del_driver(&nintendo3ds_mcu_driver);
+}
+module_exit(nintendo3ds_mcu_exit);
+
+MODULE_DESCRIPTION("Nintendo 3DS MCU system controller");
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_mcuhid.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mcuhid.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_mcuhid.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mcuhid.c	2020-01-17 09:02:23.794015632 -0300
@@ -0,0 +1,168 @@
+/*
+ *  nintendo3ds_mcuhid.c
+ *
+ *  Copyright (C) 2019 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-mcuhid"
+
+#define BTN_PWR_DOWN	BIT(0)
+#define BTN_PWR_HOLD	BIT(1)
+#define BTN_HOME_DOWN	BIT(2)
+#define BTN_WIFI_SWITCH	BIT(4)
+#define BTN_SHELL_CLOSE	BIT(5)
+
+#define BTN_MCU_ALL	\
+	(BTN_PWR_DOWN | BTN_PWR_HOLD | BTN_HOME_DOWN | \
+		BTN_WIFI_SWITCH | BTN_SHELL_CLOSE)
+
+#define MCU_MASK_REGISTER	(0x10)
+#define MCU_ACK_REGISTER	(0x18)
+
+struct nintendo3ds_mcuhid {
+	unsigned irq;
+	struct input_dev *input;
+	struct regmap *mcu_regmap;
+
+	struct work_struct work;
+};
+
+static const struct {
+	unsigned int in, out;
+} mcuhid_mappings[] = {
+	{BTN_PWR_DOWN, KEY_SUSPEND},
+	{BTN_PWR_HOLD, KEY_POWER},
+	{BTN_HOME_DOWN, KEY_HOME},
+	{BTN_WIFI_SWITCH, KEY_WWAN},
+	{BTN_SHELL_CLOSE, SW_LID},
+};
+
+static void nintendo3ds_mcuhid_report(struct work_struct *work)
+{
+	int i;
+	u32 mask;
+	struct nintendo3ds_mcuhid *mcuhid =
+		container_of(work, struct nintendo3ds_mcuhid, work);
+
+	regmap_raw_read(mcuhid->mcu_regmap, MCU_ACK_REGISTER,
+		&mask, sizeof(mask));
+
+	for (i = 0; i < ARRAY_SIZE(mcuhid_mappings); i++)
+		input_report_key(mcuhid->input, mcuhid_mappings[i].out,
+			mcuhid_mappings[i].in & mask);
+
+	input_sync(mcuhid->input);
+}
+
+static void nintendo3ds_mcuhid_setmask(struct nintendo3ds_mcuhid *mcuhid,
+										unsigned int mask)
+{
+	mask = ~mask;
+	regmap_raw_write(mcuhid->mcu_regmap, MCU_MASK_REGISTER,
+		&mask, sizeof(mask));
+}
+
+static irqreturn_t nintendo3ds_mcuhid_interrupt(int irq, void *priv)
+{
+	struct nintendo3ds_mcuhid *mcuhid = priv;
+	schedule_work(&mcuhid->work);
+	return IRQ_HANDLED;
+}
+
+static int nintendo3ds_mcuhid_probe(struct platform_device *pdev)
+{
+	int err, i;
+	unsigned irq;
+	struct input_dev *input;
+	struct regmap *mcu_regmap;
+	struct nintendo3ds_mcuhid *mcuhid;
+
+	mcu_regmap = dev_get_drvdata(pdev->dev.parent);
+	irq = platform_get_irq(pdev, 0);
+	if (!irq)
+		return -EINVAL;
+
+	mcuhid = devm_kzalloc(&pdev->dev, sizeof(*mcuhid), GFP_KERNEL);
+	if (IS_ERR(mcuhid))
+		return PTR_ERR(mcuhid);
+
+	mcuhid->mcu_regmap = mcu_regmap;
+	mcuhid->irq = irq;
+	INIT_WORK(&mcuhid->work, nintendo3ds_mcuhid_report);
+
+	input = devm_input_allocate_device(&pdev->dev);
+	input->name = "Nintendo 3DS MCU input";
+	input->id.bustype = BUS_HOST;
+	input->dev.parent = &pdev->dev;
+
+	mcuhid->input = input;
+
+	// enable all buttons
+	nintendo3ds_mcuhid_setmask(mcuhid, BTN_MCU_ALL);
+
+	set_bit(EV_KEY, input->evbit);
+	for (i = 0; i < ARRAY_SIZE(mcuhid_mappings); i++)
+		set_bit(mcuhid_mappings[i].out, input->keybit);
+
+	err = input_register_device(input);
+	if (err)
+		return err;
+
+	err = devm_request_irq(&pdev->dev, irq, nintendo3ds_mcuhid_interrupt,
+							0, "mcu_hid", mcuhid);
+	if (err) {
+		input_unregister_device(input);
+		return err;
+	}
+
+	platform_set_drvdata(pdev, mcuhid);
+	return 0;
+}
+
+static int nintendo3ds_mcuhid_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_mcuhid *mcuhid = platform_get_drvdata(pdev);
+	devm_free_irq(&pdev->dev, mcuhid->irq, mcuhid);
+	input_unregister_device(mcuhid->input);
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_mcuhid_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_mcuhid_of_match);
+
+static struct platform_driver nintendo3ds_mcuhid_driver = {
+	.probe	= nintendo3ds_mcuhid_probe,
+	.remove	= nintendo3ds_mcuhid_remove,
+
+	.driver	= {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = nintendo3ds_mcuhid_of_match,
+	},
+};
+
+module_platform_driver(nintendo3ds_mcuhid_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS MCU HID driver");
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_mmc.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mmc.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_mmc.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_mmc.c	2020-01-17 09:02:23.794015632 -0300
@@ -0,0 +1,387 @@
+/*
+ * nintendo3ds_mmc.c
+ *
+ *  Copyright (C) 2019 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/of.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/genhd.h>
+#include <linux/blk-mq.h>
+#include <linux/errno.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+
+#include "nintendo3ds_pxi.h"
+
+#define DRIVER_NAME "nintendo3ds-mmc"
+
+#define DEVICE_NAME "ctr_mmc"
+
+#define MMC_BLKSZ	(512)
+
+#define NINTENDO3DS_MMC_FIRST_MINOR 0
+#define NINTENDO3DS_MMC_MINOR_COUNT 16
+
+#define PXI_MSG_INIT_FN	(0)
+#define PXI_MSG_SIZE_FN	(1)
+#define PXI_MSG_READ_FN	(2)
+#define PXI_MSG_WRITE_FN	(3)
+
+struct nintendo3ds_mmc_host;
+struct nintendo3ds_mmc_slot {
+	spinlock_t lock;
+
+	int slot;
+	sector_t size;
+
+	struct pxi_message *msg;
+
+	struct gendisk *gd;
+	struct request_queue *q;
+	struct blk_mq_tag_set tag_set;
+
+	struct nintendo3ds_mmc_host *host;
+};
+
+struct nintendo3ds_mmc_host {
+	struct pxi_channel *chan;
+	struct device *dev;
+
+	spinlock_t host_lock;
+
+	int major;
+
+	int slot_count;
+	struct nintendo3ds_mmc_slot *slot;
+};
+
+static int mmc_readwrite(struct nintendo3ds_mmc_slot *slot,
+		u32 offset, u32 count, dma_addr_t phys_addr, int write)
+{
+	int err;
+	u32 pxi_arg;
+	struct pxi_message *msg;
+	struct nintendo3ds_mmc_host *host;
+
+	host = slot->host;
+
+	/*msg = pxi_alloc_message(host->chan, NULL,
+		write ? PXI_MSG_WRITE_FN : PXI_MSG_READ_FN, 4);*/
+
+	msg = slot->msg;
+	pxi_message_set_fn(msg, write ? PXI_MSG_WRITE_FN : PXI_MSG_READ_FN);
+
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	pxi_message_set_arg(msg, 0, slot->slot);
+	pxi_message_set_arg(msg, 1, offset);
+	pxi_message_set_arg(msg, 2, count);
+	pxi_message_set_arg(msg, 3, phys_addr);
+
+	err = pxi_send_message(host->chan, msg);
+
+	if (!err) {
+		pxi_message_get_arg(msg, 0, &pxi_arg);
+		err = (pxi_arg == count) ? 0 : -EIO;
+	}
+
+	//pxi_free_message(host->chan, msg);
+
+	return err;
+}
+
+static int mmc_readwrite_mapaddr(struct nintendo3ds_mmc_slot *slot, u32 sector,
+								u32 count, void *buffer, int write)
+{
+	dma_addr_t phys;
+	int err, dma_dir;
+	struct device *dev;
+
+	dev = slot->host->dev;
+	dma_dir = write ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	phys = dma_map_single(dev, buffer, count * MMC_BLKSZ, dma_dir);
+	if (dma_mapping_error(dev, phys))
+		return -ENOMEM;
+
+	err = mmc_readwrite(slot, sector, count, phys, write);
+
+	dma_unmap_single(dev, phys, count * MMC_BLKSZ, dma_dir);
+	return err;
+}
+
+static int mmc_xfer_bio(struct nintendo3ds_mmc_slot *slot, struct request *req)
+{
+	struct bio_vec bvec;
+	struct req_iterator i;
+
+	int dir = rq_data_dir(req);
+	sector_t sector = blk_rq_pos(req);
+
+	rq_for_each_segment(bvec, req, i) {
+		int ret;
+		sector_t sector_count = bvec.bv_len / MMC_BLKSZ;
+		char *buffer = kmap_atomic(bvec.bv_page);
+		unsigned long offset = bvec.bv_offset;
+
+		ret = mmc_readwrite_mapaddr(slot, sector, sector_count,
+									buffer + offset, dir == WRITE);
+
+		kunmap_atomic(buffer);
+
+		if (ret)
+			return ret;
+
+		sector += sector_count;
+	}
+
+	return 0;
+}
+
+static blk_status_t mmc_queue_rq(struct blk_mq_hw_ctx *hctx,
+							const struct blk_mq_queue_data *bd)
+{
+	int err;
+	blk_status_t status;
+	struct request *req;
+	struct nintendo3ds_mmc_slot *slot;
+
+	req = bd->rq;
+	blk_mq_start_request(req);
+	slot = req->rq_disk->private_data;
+
+	spin_lock(&slot->lock);
+	err = mmc_xfer_bio(slot, req);
+	if (err)
+		status = BLK_STS_IOERR;
+	else
+		status = BLK_STS_OK;
+	spin_unlock(&slot->lock);
+
+	blk_mq_end_request(req, status);
+	return status;
+}
+
+static const struct blk_mq_ops nintendo3ds_mq_ops = {
+	.queue_rq = mmc_queue_rq,
+};
+
+static int nintendo3ds_mmc_open(struct block_device *bdev, fmode_t mode)
+{
+	unsigned unit = iminor(bdev->bd_inode);
+
+	if (unit > NINTENDO3DS_MMC_MINOR_COUNT)
+		return -ENODEV;
+
+	return 0;
+}
+
+static void nintendo3ds_mmc_release(struct gendisk *disk, fmode_t mode)
+{
+}
+
+static const struct block_device_operations nintendo3ds_mmc_fops = {
+	.owner = THIS_MODULE,
+	.open = nintendo3ds_mmc_open,
+	.release = nintendo3ds_mmc_release,
+};
+
+static int mmc_slot_setup(struct nintendo3ds_mmc_host *host,
+						sector_t size, unsigned int slotn)
+{
+	struct nintendo3ds_mmc_slot *slot;
+
+	if (slotn >= host->slot_count)
+		return -EINVAL;
+
+	slot = &host->slot[slotn];
+	slot->host = host;
+	slot->size = size;
+	slot->slot = slotn;
+	spin_lock_init(&slot->lock);
+
+	slot->q = blk_mq_init_sq_queue(&slot->tag_set, &nintendo3ds_mq_ops, 1, BLK_MQ_F_SHOULD_MERGE);
+	if (IS_ERR(slot->q)) {
+		dev_err(host->dev, "failed to allocate request queue");
+		return PTR_ERR(slot->q);
+	}
+
+	slot->q->queuedata = slot;
+
+	slot->gd = alloc_disk(NINTENDO3DS_MMC_MINOR_COUNT);
+	if (IS_ERR(slot->gd)) {
+		dev_err(host->dev, "failed to allocate slot");
+		blk_cleanup_queue(slot->q);
+	}
+
+	slot->gd->major = host->major;
+	slot->gd->first_minor = slotn * NINTENDO3DS_MMC_MINOR_COUNT;
+	slot->gd->fops = &nintendo3ds_mmc_fops;
+	slot->gd->private_data = slot;
+	slot->gd->queue = slot->q;
+	snprintf(slot->gd->disk_name, 32, DEVICE_NAME "_%c", slotn + 'a');
+	set_capacity(slot->gd, size);
+
+	slot->msg = pxi_alloc_message(host->chan, NULL, 0, 4);
+
+	add_disk(slot->gd);
+	return 0;
+}
+
+static int mmc_host_reset(struct nintendo3ds_mmc_host *host)
+{
+	u32 slots;
+	struct pxi_message *msg =
+		pxi_send_message_simple(host->chan, NULL, PXI_MSG_INIT_FN, 1, 0);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+	pxi_message_get_arg(msg, 0, &slots);
+	pxi_free_message(host->chan, msg);
+	return slots;
+}
+
+static int mmc_slot_getsizes(struct nintendo3ds_mmc_host *host)
+{
+	int i, err;
+	struct pxi_message *msg =
+		pxi_alloc_message(host->chan, NULL, PXI_MSG_SIZE_FN, host->slot_count);
+	if (IS_ERR(msg))
+		return PTR_ERR(msg);
+
+	err = pxi_send_message(host->chan, msg);
+	if (err)
+		return err;
+
+	for (i = 0; i < host->slot_count && !err; i++) {
+		u32 sectors;
+		pxi_message_get_arg(msg, i, &sectors);
+		err = mmc_slot_setup(host, sectors, i);
+	}
+	pxi_free_message(host->chan, msg);
+	return err;
+}
+
+static int mmc_host_init(struct nintendo3ds_mmc_host *host)
+{
+	int i, err, slotcnt;
+	struct nintendo3ds_mmc_slot *slots;
+
+	// reset MMC controller, get the slot count
+	err = mmc_host_reset(host);
+	if (err <= 0)
+		return err;
+	else if (err > 2)
+		return -EINVAL;
+
+	slotcnt = err;
+	host->slot_count = slotcnt;
+
+	// get sector counts
+	slots = devm_kzalloc(host->dev, sizeof(*slots) * slotcnt, GFP_KERNEL);
+	if (IS_ERR(slots))
+		return PTR_ERR(slots);
+	for (i = 0; i < slotcnt; i++)
+		slots[i].host = host;
+
+	host->slot = slots;
+	return mmc_slot_getsizes(host);
+}
+
+static int nintendo3ds_mmc_probe(struct platform_device *pdev)
+{
+	int err, major = 0;
+	struct pxi_channel *pxi;
+	struct nintendo3ds_mmc_host *mmc;
+
+	pxi = pxi_acq_channel(pdev->dev.parent, &pdev->dev, "sdmmc");
+	if (IS_ERR(pxi)) {
+		dev_err(&pdev->dev, "failed to acquire PXI channel");
+		err = -ENXIO;
+		goto mmc_probe_pxirel;
+	}
+
+	major = register_blkdev(major, DEVICE_NAME);
+	if (major < 0) {
+		dev_err(&pdev->dev, "failed to get major number");
+		err = -EBUSY;
+		goto mmc_probe_pxirel;
+	}
+
+	mmc = devm_kzalloc(&pdev->dev, sizeof(*mmc), GFP_KERNEL);
+	if (IS_ERR(mmc)) {
+		dev_err(&pdev->dev, "failed to allocate driver");
+		err = PTR_ERR(mmc);
+		goto mmc_probe_pxirel;
+	}
+
+	mmc->chan = pxi;
+	mmc->dev = &pdev->dev;
+	mmc->major = major;
+
+	err = mmc_host_init(mmc);
+	if (err != 0) {
+		dev_err(&pdev->dev, "failed to initialize MMC");
+		err = -EIO;
+		goto mmc_probe_pxirel;
+	}
+
+	return 0;
+
+mmc_probe_pxirel:
+	pxi_rel_channel(pxi);
+	return err;
+}
+
+// TODO: fix this thing being removed and stuff
+static int nintendo3ds_mmc_remove(struct platform_device *pdev)
+{
+	struct nintendo3ds_mmc_host *host = dev_get_drvdata(&pdev->dev);
+	BUG_ON(host == NULL);
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_mmc_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_mmc_of_match);
+
+static struct platform_driver nintendo3ds_mmc_driver = {
+	.probe	= nintendo3ds_mmc_probe,
+	.remove = nintendo3ds_mmc_remove,
+
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = nintendo3ds_mmc_of_match,
+	},
+};
+
+module_platform_driver(nintendo3ds_mmc_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Nintendo 3DS PXI SD/MMC driver");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_pxi.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_pxi.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_pxi.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_pxi.c	2020-02-19 17:31:13.060308357 -0300
@@ -0,0 +1,672 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *  nintendo3ds_pxi.c
+ *
+ *  Copyright (C) 2020 Wolfvak
+ *
+ *  Based on virtio_mmio.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DRIVER_NAME "nintendo3ds-pxi"
+#define pr_fmt(str)	DRIVER_NAME ": " str
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/genalloc.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/dma-mapping.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+
+#include <linux/virtio.h>
+#include <linux/virtio_config.h>
+#include <linux/virtio_ring.h>
+
+#include <linux/sched.h>
+#include <linux/kthread.h>
+
+#define VIRTIO_PXI_MAX_DEVICES	16
+#define VIRTIO_PXI_VRING_ALIGN	PAGE_SIZE
+#define VIRTIO_PXI_EXPECTED_MAGIC	('v' | 'i' << 8 | 'r' << 16 | 't' << 24)
+
+#define REG_PXI_SYNC32	0x00
+#define REG_PXI_SYNC_RX	0x00
+#define REG_PXI_SYNC_TX	0x01
+#define REG_PXI_SYNC_CNT	0x03
+#define REG_PXI_CNT	0x04
+#define REG_PXI_TX	0x08
+#define REG_PXI_RX	0x0c
+
+#define PXI_CNT_TX_FULL	BIT(1)
+#define PXI_CNT_TX_IRQ	BIT(2)
+#define PXI_CNT_FIFO_FLUSH	BIT(3)
+#define PXI_CNT_RX_EMPTY	BIT(8)
+#define PXI_CNT_RX_IRQ	BIT(10)
+#define PXI_CNT_ERROR	BIT(14)
+#define PXI_CNT_ENABLE	BIT(15)
+
+#define PXI_SYNC_CNT_TRIGGER	BIT(6)
+#define PXI_SYNC_CNT_ENABLE_IRQ	BIT(7)
+
+#define PXI_FIFO_DEPTH	16
+
+/*
+ virtio transport protocol
+ [23:0] = 24bit payload
+ [24] = command type (0 = read, 1 = write)
+ [31:25] = pxi device id
+*/
+#define VIRTIO_PXI_CMD(dev, data, cmd)	(((dev) << 25) | ((cmd) << 24) | (data))
+#define VIRTIO_PXI_CMD_RREG(dev, data)	VIRTIO_PXI_CMD(dev, data, 0)
+#define VIRTIO_PXI_CMD_WREG(dev, data)	VIRTIO_PXI_CMD(dev, data, 1)
+
+
+/* 5bit virtio transport registers */
+#define VIRTIO_PXI_REG_MAGIC_VALUE	0x00
+#define VIRTIO_PXI_REG_QUEUE_WINDOW	0x01
+#define VIRTIO_PXI_REG_CFG_WINDOW	0x02
+#define VIRTIO_PXI_REG_DEVICE_ID	0x03
+#define VIRTIO_PXI_REG_VENDOR_ID	0x04
+#define VIRTIO_PXI_REG_STATUS	0x05
+#define VIRTIO_PXI_REG_DEVICE_FEATURES_LO	0x06
+#define VIRTIO_PXI_REG_DEVICE_FEATURES_HI	0x07
+#define VIRTIO_PXI_REG_DRIVER_FEATURES_LO	0x08
+#define VIRTIO_PXI_REG_DRIVER_FEATURES_HI	0x09
+#define VIRTIO_PXI_REG_CONFIG_GENERATION	0x0A
+
+/*
+ queue register cmd format:
+ 	[4:0] = VIRTIO_PXI_REG_QUEUE_WINDOW
+ 	[7:4] = queue register
+ 	[15:8] = queue index
+ 	[24:16] = reserved, SBZ
+*/
+#define VIRTIO_PXI_REG_QUEUE(idx, reg)	(((idx) << 8) | ((reg) << 4) | VIRTIO_PXI_REG_QUEUE_WINDOW)
+#define VIRTIO_PXI_REG_QUEUE_NUM_MAX	0x00
+#define VIRTIO_PXI_REG_QUEUE_NUM_CUR	0x01
+#define VIRTIO_PXI_REG_QUEUE_READY	0x02
+#define VIRTIO_PXI_REG_QUEUE_NOTIFY	0x03
+#define VIRTIO_PXI_REG_QUEUE_DESC	0x04
+#define VIRTIO_PXI_REG_QUEUE_AVAIL	0x05
+#define VIRTIO_PXI_REG_QUEUE_USED	0x06
+
+/*
+ config register cmd format:
+ 	[3:0] = VIRTIO_PXI_REG_CFG_WINDOW
+ 	[15:4] = register offset
+ 	[24:15] = reserved, SBZ
+*/
+#define VIRTIO_PXI_REG_CONFIG(reg)	(((reg) << 4) | VIRTIO_PXI_REG_CFG_WINDOW)
+
+
+#define to_virtio_pxi_device(_virt_dev) \
+	container_of(_virt_dev, struct virtio_pxi_device, vdev)
+
+#define to_pxi_controller(_virt_dev) \
+	container_of(_virt_dev, struct pxi_controller, vdev[(_virt_dev)->pxi_id])
+
+struct virtio_pxi_device {
+	unsigned pxi_id;
+
+	spinlock_t lock;
+	struct virtio_device vdev;
+	struct list_head virtqueues;
+};
+
+struct virtio_pxi_vq_info {
+	struct virtqueue *vq;
+	struct list_head node;
+};
+
+struct pxi_controller {
+	struct platform_device *pdev;
+	void __iomem *base;
+	unsigned sync_irq, tx_irq, rx_irq;
+
+	//struct mutex fifo_lock;
+	spinlock_t fifo_lock;
+	wait_queue_head_t fifo_wq;
+
+	u32 dev_count;
+	struct virtio_pxi_device vdev[VIRTIO_PXI_MAX_DEVICES];
+};
+
+#define PXI_TX_TIMEOUT	msecs_to_jiffies(1000) // should respond quickly
+#define PXI_RX_TIMEOUT	msecs_to_jiffies(20000) // give it plenty of time to respond
+
+/* PXI hardware wrappers */
+/*static void pxi_corgi_debug(struct pxi_controller *pxi, const char *str)
+{ while(*str) iowrite8(*(str++), pxi->base + REG_PXI_RX); } // only in corgi3ds*/
+
+static int pxi_is_tx_full(struct pxi_controller *pxi)
+{ return ioread16(pxi->base + REG_PXI_CNT) & PXI_CNT_TX_FULL; }
+static int pxi_is_rx_notempty(struct pxi_controller *pxi)
+{ return !(ioread16(pxi->base + REG_PXI_CNT) & PXI_CNT_RX_EMPTY); }
+
+static irqreturn_t pxi_tx_notfull_irq(int irq, void *opaque)
+{
+	struct pxi_controller *pxi = opaque;
+	wake_up_interruptible(&pxi->fifo_wq);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t pxi_rx_notempty_irq(int irq, void *opaque)
+{
+	struct pxi_controller *pxi = opaque;
+	wake_up_interruptible(&pxi->fifo_wq);
+	return IRQ_HANDLED;
+}
+
+static int pxi_send_recv(struct pxi_controller *pxi, const u32 *ww,
+							int nw, u32 *wr, int nr)
+{
+	//long tout;
+	unsigned long flags;
+
+	//mutex_lock(&pxi->fifo_lock);
+	spin_lock_irqsave(&pxi->fifo_lock, flags);
+	while(nw > 0) { // send
+		/*tout = wait_event_interruptible_timeout(
+			pxi->fifo_wq, !pxi_is_tx_full(pxi), PXI_TX_TIMEOUT
+		);
+		BUG_ON(tout <= 0);*/
+
+		while(pxi_is_tx_full(pxi));
+
+		iowrite32(*(ww++), pxi->base + REG_PXI_TX);
+		nw--;
+	}
+
+	while(nr > 0) { // recv
+		/*tout = wait_event_interruptible_timeout(
+			pxi->fifo_wq, pxi_is_rx_notempty(pxi), PXI_RX_TIMEOUT
+		);
+		BUG_ON(tout <= 0);*/
+
+		while(!pxi_is_rx_notempty(pxi));
+
+		*(wr++) = ioread32(pxi->base + REG_PXI_RX);
+		nr--;
+	}
+	//mutex_unlock(&pxi->fifo_lock);
+	spin_unlock_irqrestore(&pxi->fifo_lock, flags);
+
+	return 0;
+}
+
+static void pxi_reset_controller(struct pxi_controller *pxi)
+{
+	int i;
+
+	iowrite32(0, pxi->base + REG_PXI_SYNC32);
+	iowrite16(PXI_CNT_FIFO_FLUSH | PXI_CNT_ERROR | PXI_CNT_ENABLE,
+		pxi->base + REG_PXI_CNT);
+
+	for (i = 0; i < PXI_FIFO_DEPTH; i++)
+		ioread32(pxi->base + REG_PXI_RX);
+
+	iowrite8(0, pxi->base + REG_PXI_SYNC_TX);
+	iowrite16(0, pxi->base + REG_PXI_CNT);
+
+	iowrite8(PXI_SYNC_CNT_ENABLE_IRQ, pxi->base + REG_PXI_SYNC_CNT);
+	iowrite16(PXI_CNT_RX_IRQ | PXI_CNT_TX_IRQ | PXI_CNT_ERROR | PXI_CNT_FIFO_FLUSH | PXI_CNT_ENABLE,
+		pxi->base + REG_PXI_CNT);
+
+	//mutex_init(&pxi->fifo_lock);
+	spin_lock_init(&pxi->fifo_lock);
+}
+
+/* Virtio stuff */
+static u32 vpxi_read_reg(struct pxi_controller *pxi, u32 dev, u32 reg)
+{
+	u32 ret, cmd[1] = { VIRTIO_PXI_CMD_RREG(dev, reg) };
+	pxi_send_recv(pxi, cmd, 1, &ret, 1);
+	return ret;
+}
+
+static int vpxi_write_reg(struct pxi_controller *pxi,
+							u32 dev, u32 reg, u32 val)
+{
+	u32 cmd[2] = { VIRTIO_PXI_CMD_WREG(dev, reg), val };
+	return pxi_send_recv(pxi, cmd, 2, NULL, 0);
+}
+
+static void vpxi_get(struct virtio_device *vdev, unsigned offset,
+		   void *buf, unsigned len)
+{
+	u8 *bytebuf;
+	u32 old_gen, new_gen;
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+
+	bytebuf = buf;
+
+	do {
+		unsigned i;
+		old_gen = vpxi_read_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_CONFIG_GENERATION);
+
+		for (i = 0; i < len; i++)
+			bytebuf[i] = vpxi_read_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_CONFIG(offset + i));
+
+		new_gen = vpxi_read_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_CONFIG_GENERATION);
+	} while(old_gen != new_gen);
+}
+
+static void vpxi_set(struct virtio_device *vdev, unsigned offset,
+		   const void *buf, unsigned len)
+{
+	unsigned i;
+	const u8 *bytebuf;
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+
+	bytebuf = buf;
+	for (i = 0; i < len; i++)
+		vpxi_write_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_CONFIG(offset + i), bytebuf[i]);
+}
+
+static u32 vpxi_generation(struct virtio_device *vdev)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+	return vpxi_read_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_CONFIG_GENERATION);
+}
+
+static u8 vpxi_get_status(struct virtio_device *vdev)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+	return vpxi_read_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_STATUS) & 0xff;
+}
+
+static void vpxi_set_status(struct virtio_device *vdev, u8 status)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+
+	/* We should never be setting status to 0. */
+	BUG_ON(status == 0);
+
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_STATUS, status);
+}
+
+static void vpxi_reset(struct virtio_device *vdev)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_STATUS, 0);
+}
+
+static bool vpxi_notify(struct virtqueue *vq)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vq->vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(vq->index, VIRTIO_PXI_REG_QUEUE_NOTIFY), 1);
+	return true;
+}
+
+/* notify vdev on interrupt */
+static irqreturn_t vpxi_interrupt(int irq, void *data)
+{
+	struct pxi_controller *pxi = data;
+	struct virtio_pxi_device *vpxi_dev;
+	struct virtio_pxi_vq_info *info;
+	u8 pxi_port, pxi_dev;
+	unsigned long flags;
+	irqreturn_t ret = IRQ_NONE;
+
+	pxi_port = ioread8(pxi->base + REG_PXI_SYNC_RX);
+	pxi_dev = pxi_port & 0x7f;
+	if (pxi_dev >= pxi->dev_count)
+		return ret; // lolnope, ignore
+
+	iowrite8(1, pxi->base + REG_PXI_SYNC_TX);
+
+	vpxi_dev = &pxi->vdev[pxi_dev];
+	if (unlikely(pxi_port & 0x80)) { // config change
+		virtio_config_changed(&vpxi_dev->vdev);
+	} else { // virtqueue change
+		spin_lock_irqsave(&vpxi_dev->lock, flags);
+		list_for_each_entry(info, &vpxi_dev->virtqueues, node)
+			ret |= vring_interrupt(irq, info->vq);
+		spin_unlock_irqrestore(&vpxi_dev->lock, flags);
+	}
+
+	iowrite8(0, pxi->base + REG_PXI_SYNC_TX);
+	return ret;
+}
+
+static void vpxi_del_vq(struct virtqueue *vq)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vq->vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+	struct virtio_pxi_vq_info *info = vq->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&vpxi_dev->lock, flags);
+	list_del(&info->node);
+	spin_unlock_irqrestore(&vpxi_dev->lock, flags);
+
+	/* Select and deactivate the queue */
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(vq->index, VIRTIO_PXI_REG_QUEUE_READY), 0);
+	WARN_ON(vpxi_read_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(vq->index, VIRTIO_PXI_REG_QUEUE_READY)));
+
+	vring_del_virtqueue(vq);
+
+	kfree(info);
+}
+
+static void vpxi_del_vqs(struct virtio_device *vdev)
+{
+	struct virtqueue *vq, *n;
+
+	list_for_each_entry_safe(vq, n, &vdev->vqs, list)
+		vpxi_del_vq(vq);
+}
+
+static struct virtqueue *vpxi_setup_vq(struct virtio_device *vdev, unsigned index,
+				  void (*callback)(struct virtqueue *vq),
+				  const char *name, bool ctx)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+	struct virtio_pxi_vq_info *info;
+	struct virtqueue *vq;
+	unsigned long flags;
+	unsigned int num;
+	int err;
+
+	if (!name)
+		return NULL;
+
+	if (vpxi_read_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_READY))) {
+		pr_err("VIRTIO_PXI_REG_QUEUE_READY set on dev %d", vpxi_dev->pxi_id);
+		err = -ENOENT;
+		goto error_available;
+	}
+
+	info = kmalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		err = -ENOMEM;
+		goto error_kmalloc;
+	}
+
+	num = vpxi_read_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_NUM_MAX));
+	if (num == 0) {
+		pr_err("VIRTIO_PXI_REG_QUEUE_NUM_MAX is zero on dev %d", vpxi_dev->pxi_id);
+		err = -ENOENT;
+		goto error_new_virtqueue;
+	}
+
+	vq = vring_create_virtqueue(index, num, VIRTIO_PXI_VRING_ALIGN, vdev,
+				 false, false, ctx, vpxi_notify, callback, name);
+	if (!vq) {
+		err = -ENOMEM;
+		goto error_new_virtqueue;
+	}
+
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_NUM_CUR), virtqueue_get_vring_size(vq));
+
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_DESC), virtqueue_get_desc_addr(vq));
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_AVAIL), virtqueue_get_avail_addr(vq));
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_USED), virtqueue_get_used_addr(vq));
+
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_READY), 1);
+
+	vq->priv = info;
+	info->vq = vq;
+
+	spin_lock_irqsave(&vpxi_dev->lock, flags);
+	list_add(&info->node, &vpxi_dev->virtqueues);
+	spin_unlock_irqrestore(&vpxi_dev->lock, flags);
+
+	return vq;
+
+error_new_virtqueue:
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_READY), 0);
+	WARN_ON(vpxi_read_reg(pxi, vpxi_dev->pxi_id,
+		VIRTIO_PXI_REG_QUEUE(index, VIRTIO_PXI_REG_QUEUE_READY)));
+	kfree(info);
+error_kmalloc:
+error_available:
+	return ERR_PTR(err);
+}
+
+static int vpxi_find_vqs(struct virtio_device *vdev, unsigned nvqs,
+		       struct virtqueue *vqs[],
+		       vq_callback_t *callbacks[],
+		       const char * const names[],
+		       const bool *ctx,
+		       struct irq_affinity *desc)
+{
+	int i, queue_idx = 0;
+
+	for (i = 0; i < nvqs; ++i) {
+		if (!names[i]) {
+			vqs[i] = NULL;
+			continue;
+		}
+
+		vqs[i] = vpxi_setup_vq(vdev, queue_idx++, callbacks[i], names[i],
+				     ctx ? ctx[i] : false);
+		if (IS_ERR(vqs[i])) {
+			vpxi_del_vqs(vdev);
+			return PTR_ERR(vqs[i]);
+		}
+	}
+
+	return 0;
+}
+
+static u64 vpxi_get_features(struct virtio_device *vdev)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+
+	return vpxi_read_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_DEVICE_FEATURES_LO) |
+		((u64)vpxi_read_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_DEVICE_FEATURES_HI) << 32ULL);
+}
+
+static int vpxi_finalize_features(struct virtio_device *vdev)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+
+	vring_transport_features(vdev);
+	if (!__virtio_test_bit(vdev, VIRTIO_F_VERSION_1)) {
+		dev_err(&vdev->dev, "New virtio-pxi devices (version 2) must provide VIRTIO_F_VERSION_1 feature!\n");
+		return -EINVAL;
+	}
+
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_DRIVER_FEATURES_LO, vdev->features);
+	vpxi_write_reg(pxi, vpxi_dev->pxi_id, VIRTIO_PXI_REG_DRIVER_FEATURES_HI, vdev->features >> 32);
+	return 0;
+}
+
+static const char *vpxi_bus_name(struct virtio_device *vdev)
+{
+	struct virtio_pxi_device *vpxi_dev = to_virtio_pxi_device(vdev);
+	struct pxi_controller *pxi = to_pxi_controller(vpxi_dev);
+	return pxi->pdev->name;
+}
+
+static const struct virtio_config_ops virtio_pxi_config_ops = {
+	.get		= vpxi_get,
+	.set		= vpxi_set,
+	.generation	= vpxi_generation,
+	.get_status	= vpxi_get_status,
+	.set_status	= vpxi_set_status,
+	.reset		= vpxi_reset,
+	.find_vqs	= vpxi_find_vqs,
+	.del_vqs	= vpxi_del_vqs,
+	.get_features	= vpxi_get_features,
+	.finalize_features = vpxi_finalize_features,
+	.bus_name	= vpxi_bus_name,
+};
+
+static void virtio_pxi_release_dev(struct device *_d)
+{}
+
+/* virtio stuff */
+static int pxi_init_virtio(struct pxi_controller *pxi)
+{
+	int err;
+	u32 devcnt, i;
+
+	for (devcnt = 0; devcnt < VIRTIO_PXI_MAX_DEVICES; devcnt++) {
+		if (vpxi_read_reg(pxi, devcnt, VIRTIO_PXI_REG_MAGIC_VALUE) != VIRTIO_PXI_EXPECTED_MAGIC)
+			break;
+	}
+
+	if (!devcnt) {
+		pr_info("no pxi virtio device were found");
+		return 0;
+	}
+
+	err = dma_set_mask_and_coherent(&pxi->pdev->dev, DMA_BIT_MASK(32));
+	if (err) {
+		pr_err("failed to enable DMA (%d)", err);
+		return err;
+	}
+
+	pxi->dev_count = devcnt;
+	for (i = 0; i < devcnt; i++) {
+		struct virtio_pxi_device *vpxi_dev = &pxi->vdev[i];
+		u32 devid, vendorid;
+
+		INIT_LIST_HEAD(&vpxi_dev->virtqueues);
+
+		devid = vpxi_read_reg(pxi, i, VIRTIO_PXI_REG_DEVICE_ID);
+		vendorid = vpxi_read_reg(pxi, i, VIRTIO_PXI_REG_VENDOR_ID);
+
+		vpxi_dev->pxi_id = i;
+		spin_lock_init(&vpxi_dev->lock);
+
+		vpxi_dev->vdev.dev.parent = &pxi->pdev->dev;
+		vpxi_dev->vdev.dev.release = virtio_pxi_release_dev;
+		vpxi_dev->vdev.config = &virtio_pxi_config_ops;
+
+		vpxi_dev->vdev.id.device = devid;
+		vpxi_dev->vdev.id.vendor = vendorid;
+
+		err = register_virtio_device(&vpxi_dev->vdev);
+	}
+
+	return 0;
+}
+
+// driver management
+static int nintendo3ds_pxi_probe(struct platform_device *pdev)
+{
+	int err;
+	void __iomem *io_regs;
+	struct resource *memres;
+	struct pxi_controller *pxi;
+	unsigned sync_irq, tx_irq, rx_irq;
+
+	sync_irq = platform_get_irq(pdev, 0);
+	tx_irq = platform_get_irq(pdev, 1);
+	rx_irq = platform_get_irq(pdev, 2);
+
+	if (sync_irq < 0 || tx_irq < 0 || rx_irq < 0) {
+		pr_err("failed to retrieve interrupts");
+		return -EINVAL;
+	}
+
+	pxi = devm_kzalloc(&pdev->dev, sizeof(*pxi), GFP_KERNEL);
+	if (IS_ERR(pxi)) {
+		pr_err("failed to allocate controller memory");
+		return PTR_ERR(pxi);
+	}
+
+	memres = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(memres)) {
+		pr_err("failed to retrieve IO space");
+		return PTR_ERR(memres);
+	}
+
+	io_regs = devm_ioremap_resource(&pdev->dev, memres);
+	if (IS_ERR(io_regs)) {
+		return PTR_ERR(io_regs);
+	}
+
+	pxi->pdev = pdev;
+	pxi->base = io_regs;
+	pxi->tx_irq = tx_irq;
+	pxi->rx_irq = rx_irq;
+	pxi->sync_irq = sync_irq;
+	init_waitqueue_head(&pxi->fifo_wq);
+
+	pxi_reset_controller(pxi);
+	platform_set_drvdata(pdev, pxi);
+
+	err = devm_request_irq(&pdev->dev, sync_irq,
+		vpxi_interrupt, IRQF_IRQPOLL, "pxi_sync", pxi);
+	if (err)
+		return err;
+
+	err = devm_request_irq(&pdev->dev, tx_irq,
+		pxi_tx_notfull_irq, 0, "pxi_tx", pxi);
+	if (err)
+		return err;
+
+	err = devm_request_irq(&pdev->dev, rx_irq,
+		pxi_rx_notempty_irq, 0, "pxi_rx", pxi);
+	if (err)
+		return err;
+
+	err = pxi_init_virtio(pxi);
+	if (err) {
+		pr_err("failed to init virtio bridge (%d)", err);
+		return err;
+	}
+
+	pr_info("discovered %d virtio devices", pxi->dev_count);
+	return 0;
+}
+
+static int nintendo3ds_pxi_remove(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+
+static const struct of_device_id nintendo3ds_pxi_of_match[] = {
+		{ .compatible = "nintendo3ds," DRIVER_NAME, },
+		{},
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_pxi_of_match);
+
+static struct platform_driver nintendo3ds_pxi_driver = {
+	.probe	= nintendo3ds_pxi_probe,
+	.remove = nintendo3ds_pxi_remove,
+
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(nintendo3ds_pxi_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_pxi_driver);
+
+MODULE_AUTHOR("Wolfvak");
+MODULE_DESCRIPTION("Nintendo 3DS PXI Virtio bridge");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_reset.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_reset.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_reset.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_reset.c	2020-01-17 09:02:23.796016632 -0300
@@ -0,0 +1,68 @@
+/*
+ *  nintendo3ds_reset.c
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  based on msm-poweroff.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/pm.h>
+#include <linux/reboot.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-reset"
+#define POWER_REGISTER	0x20
+
+static struct regmap *mcu_regmap;
+static int reset_restart(struct notifier_block *nb, unsigned long act,
+			   void *data)
+{
+	regmap_write(mcu_regmap, POWER_REGISTER, 0x04);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block restart_nb = {
+	.notifier_call = reset_restart,
+	.priority = 128,
+};
+
+static void reset_poweroff(void)
+{
+	regmap_write(mcu_regmap, POWER_REGISTER, 0x01);
+}
+
+static int nintendo3ds_reset_probe(struct platform_device *pdev)
+{
+	mcu_regmap = dev_get_drvdata(pdev->dev.parent);
+
+	register_restart_handler(&restart_nb);
+	pm_power_off = reset_poweroff;
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_reset_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_reset_of_match);
+
+static struct platform_driver nintendo3ds_reset_driver = {
+	.probe = nintendo3ds_reset_probe,
+
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(nintendo3ds_reset_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_reset_driver);
+
+MODULE_DESCRIPTION("Nintendo 3DS power control driver");
+MODULE_AUTHOR("Sergi Granell, <xerpi.g.12@gmail.com>");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_rtc.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_rtc.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_rtc.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_rtc.c	2020-02-20 13:16:27.383348847 -0300
@@ -0,0 +1,115 @@
+/*
+ *  nintendo3ds_rtc.c
+ *
+ *  Copyright (C) 2016 Sergi Granell
+ *  based on rtc-em3207.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/of.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME "nintendo3ds-rtc"
+
+#define RTC_REGISTER	0x30
+
+struct nintendo3ds_rtc {
+	struct regmap *mcu_regmap;
+	struct rtc_device *rtc_dev;
+};
+
+static int nintendo3ds_rtc_get_time(struct device *dev, struct rtc_time *tm)
+{
+	struct nintendo3ds_rtc *n3ds_rtc = dev_get_drvdata(dev);
+	struct regmap *mcu_regmap = n3ds_rtc->mcu_regmap;
+	int err;
+	u8 buf[8];
+
+	err = regmap_bulk_read(mcu_regmap, RTC_REGISTER, buf, sizeof(buf));
+	if (err < 0)
+		return err;
+
+	tm->tm_sec	= bcd2bin(buf[0]) % 60;
+	tm->tm_min	= bcd2bin(buf[1]) % 60;
+	tm->tm_hour	= bcd2bin(buf[2]) % 24;
+	tm->tm_mday	= bcd2bin(buf[4]) % 32;
+	tm->tm_mon	= (bcd2bin(buf[5]) - 1) % 12;
+	tm->tm_year	= bcd2bin(buf[6]) + 100;
+	return 0;
+}
+
+static int nintendo3ds_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct nintendo3ds_rtc *n3ds_rtc = dev_get_drvdata(dev);
+	struct regmap *mcu_regmap = n3ds_rtc->mcu_regmap;
+	u8 buf[8];
+
+	buf[0] = bin2bcd(tm->tm_sec);
+	buf[1] = bin2bcd(tm->tm_min);
+	buf[2] = bin2bcd(tm->tm_hour);
+	buf[4] = bin2bcd(tm->tm_mday);
+	buf[5] = bin2bcd(tm->tm_mon + 1);
+	buf[6] = bin2bcd(tm->tm_year - 100);
+
+	return regmap_bulk_write(mcu_regmap, RTC_REGISTER, buf, sizeof(buf));
+}
+
+static const struct rtc_class_ops nintendo3ds_rtc_ops = {
+	.read_time	= nintendo3ds_rtc_get_time,
+	.set_time	= nintendo3ds_rtc_set_time,
+};
+
+static int nintendo3ds_rtc_probe(struct platform_device *pdev)
+{
+	struct rtc_device *rtc;
+	struct nintendo3ds_rtc *n3ds_rtc;
+	struct regmap *mcu_regmap = dev_get_drvdata(pdev->dev.parent);
+
+	n3ds_rtc = devm_kzalloc(&pdev->dev, sizeof(*n3ds_rtc), GFP_KERNEL);
+	if (IS_ERR(n3ds_rtc))
+		return PTR_ERR(n3ds_rtc);
+
+	n3ds_rtc->mcu_regmap = mcu_regmap;
+
+	platform_set_drvdata(pdev, n3ds_rtc);
+
+	rtc = devm_rtc_device_register(&pdev->dev, DRIVER_NAME,
+		&nintendo3ds_rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(rtc))
+		return PTR_ERR(rtc);
+
+	n3ds_rtc->rtc_dev = rtc;
+	return 0;
+}
+
+static int nintendo3ds_rtc_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static const struct of_device_id nintendo3ds_rtc_of_match[] = {
+	{ .compatible = "nintendo3ds," DRIVER_NAME, },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_rtc_of_match);
+
+static struct platform_driver nintendo3ds_rtc_driver = {
+	.probe = nintendo3ds_rtc_probe,
+	.remove = nintendo3ds_rtc_remove,
+
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(nintendo3ds_rtc_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_rtc_driver);
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_spi.c linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_spi.c
--- linux-5.4.12/drivers/platform/nintendo3ds/nintendo3ds_spi.c	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/nintendo3ds_spi.c	2020-01-17 09:02:23.798017631 -0300
@@ -0,0 +1,211 @@
+/*
+ *  nintendo3ds_spi.c
+ *
+ *  Copyright (C) 2016 Sergi Granell (xerpi)
+ *  Copyright (C) 2019 Wolfvak
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+
+#define DRIVER_NAME "nintendo3ds-spi"
+
+struct nintendo3ds_spi {
+	struct spi_master *master;
+
+	char __iomem *regs;
+	u32 chipselect;
+};
+
+/* SPI registers */
+
+#define REG_SPI_CNT		0x00
+#define REG_SPI_DONE	0x04
+#define REG_SPI_BLKLEN	0x08
+#define REG_SPI_FIFO	0x0C
+#define REG_SPI_STAT	0x10
+
+#define SPI_CNT_CHIPSELECT(n)	((n) << 6)
+#define SPI_CNT_XFER_READ		(0 << 13)
+#define SPI_CNT_XFER_WRITE		(1 << 13)
+#define SPI_CNT_BUSY			BIT(15)
+#define SPI_CNT_ENABLE			BIT(15)
+
+#define SPI_FIFO_BUSY	BIT(0)
+#define SPI_FIFO_WIDTH	0x20
+
+static u8 spi_get_baudrate_for_freq(u32 freq)
+{
+	switch (freq) {
+	case 4000000:
+		return 5;
+	case 2000000:
+		return 4;
+	case 1000000:
+		return 3;
+	case 512000:
+		return 2;
+	case 256000:
+		return 1;
+	case 128000:
+	default:
+		return 0;
+	}
+}
+
+static void nintendo3ds_spi_waitbusy(char __iomem *regs) {
+	while(ioread32(regs + REG_SPI_CNT) & SPI_CNT_BUSY);
+}
+
+static void nintendo3ds_spi_waitfifo(char __iomem *regs) {
+	while(ioread32(regs + REG_SPI_STAT) & SPI_FIFO_BUSY);
+}
+
+static void nintendo3ds_spi_doxfer(char __iomem *regs, u32 reg,
+									u32 *buf, u32 len, bool read)
+{
+	u32 pos = 0;
+
+	iowrite32(len, regs + REG_SPI_BLKLEN);
+	iowrite32(reg | (read ? SPI_CNT_XFER_READ : SPI_CNT_XFER_WRITE)
+			| SPI_CNT_ENABLE, regs + REG_SPI_CNT);
+
+	do {
+		if ((pos % SPI_FIFO_WIDTH) == 0)
+			nintendo3ds_spi_waitfifo(regs);
+
+		if (read) {
+			buf[pos / 4] = ioread32(regs + REG_SPI_FIFO);
+		} else {
+			iowrite32(buf[pos / 4], regs + REG_SPI_FIFO);
+		}
+
+		pos += 4;
+	} while(pos < len);
+}
+
+static void nintendo3ds_spi_set_cs(struct spi_device *spi, bool enable)
+{
+	struct nintendo3ds_spi *n3ds_spi = spi_master_get_devdata(spi->master);
+	n3ds_spi->chipselect = spi->chip_select;
+}
+
+static int nintendo3ds_spi_transfer_one(struct spi_master *master,
+				  struct spi_device *spi,
+				  struct spi_transfer *tfr)
+{
+	size_t len;
+	u32 *buf, reg_config;
+	struct nintendo3ds_spi *n3ds_spi = spi_master_get_devdata(master);
+
+	len = tfr->len;
+	reg_config = spi_get_baudrate_for_freq(spi->max_speed_hz) |
+				SPI_CNT_CHIPSELECT(n3ds_spi->chipselect);
+
+	nintendo3ds_spi_waitbusy(n3ds_spi->regs);
+
+	if (tfr->tx_buf) {
+		buf = (u32*)tfr->tx_buf;
+		nintendo3ds_spi_doxfer(n3ds_spi->regs, reg_config, buf, len, false);
+	} else if (tfr->rx_buf) {
+		buf = (u32*)tfr->rx_buf;
+		nintendo3ds_spi_doxfer(n3ds_spi->regs, reg_config, buf, len, true);
+	} else {
+		dev_err(&spi->dev, "%s: null SPI transfer", __func__);
+		return -EINVAL;
+	}
+
+	if (spi_transfer_is_last(master, tfr)) {
+		nintendo3ds_spi_waitbusy(n3ds_spi->regs);
+		iowrite32(0, n3ds_spi->regs + REG_SPI_DONE);
+	}
+
+	spi_finalize_current_transfer(master);
+	return 0;
+}
+
+static int nintendo3ds_spi_probe(struct platform_device *pdev)
+{
+	struct nintendo3ds_spi *n3ds_spi;
+	struct spi_master *master;
+	struct resource *mem;
+	int ret;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct nintendo3ds_spi));
+	if (IS_ERR(master)) {
+		dev_err(&pdev->dev, "failed to allocate driver");
+		return PTR_ERR(master);
+	}
+
+	platform_set_drvdata(pdev, master);
+	n3ds_spi = spi_master_get_devdata(master);
+
+	n3ds_spi->master = master;
+	master->bus_num = pdev->id;
+	master->set_cs = nintendo3ds_spi_set_cs;
+	master->transfer_one = nintendo3ds_spi_transfer_one;
+	master->num_chipselect = 2;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->flags = SPI_MASTER_HALF_DUPLEX;
+	master->dev.of_node = pdev->dev.of_node;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (IS_ERR(mem))
+		return PTR_ERR(mem);
+
+	n3ds_spi->regs = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(n3ds_spi->regs))
+		return PTR_ERR(n3ds_spi->regs);
+
+	/* Stop any possible running transfer */
+	iowrite32(0, n3ds_spi->regs + REG_SPI_CNT);
+
+	ret = devm_spi_register_master(&pdev->dev, master);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register SPI master (%d)", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nintendo3ds_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	spi_master_put(master);
+	return 0;
+}
+
+
+MODULE_ALIAS("platform:" DRIVER_NAME);
+
+static const struct of_device_id nintendo3ds_spi_of_match[] = {
+	{ .compatible = "nintendo3ds,nintendo3ds-spi", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, nintendo3ds_spi_of_match);
+
+static struct platform_driver nintendo3ds_spi_driver = {
+	.probe	= nintendo3ds_spi_probe,
+	.remove	= nintendo3ds_spi_remove,
+
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table	= of_match_ptr(nintendo3ds_spi_of_match),
+	},
+};
+module_platform_driver(nintendo3ds_spi_driver);
+
+MODULE_AUTHOR("Sergi Granell <xerpi.g.12@gmail.com>");
+MODULE_DESCRIPTION("Nintendo 3DS SPI driver");
+MODULE_LICENSE("GPL");
diff -Naur '--exclude=certs' linux-5.4.12/drivers/platform/nintendo3ds/stQAlkUp linux-3ds/drivers/platform/nintendo3ds/stQAlkUp
--- linux-5.4.12/drivers/platform/nintendo3ds/stQAlkUp	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/drivers/platform/nintendo3ds/stQAlkUp	2020-01-21 18:58:24.076096737 -0300
@@ -0,0 +1,26 @@
+!<thin>
+//                                              248       `
+nintendo3ds_input.o/
+nintendo3ds_spi.o/
+nintendo3ds_codec.o/
+nintendo3ds_pxi.o/
+nintendo3ds_i2c.o/
+nintendo3ds_mcu.o/
+nintendo3ds_rtc.o/
+nintendo3ds_leds.o/
+nintendo3ds_reset.o/
+nintendo3ds_mcuhid.o/
+nintendo3ds_charger.o/
+nintendo3ds_backlight.o/
+/0              0           0     0     644     107824    `
+/21             0           0     0     644     128296    `
+/40             0           0     0     644     145176    `
+/61             0           0     0     644     147788    `
+/80             0           0     0     644     82708     `
+/99             0           0     0     644     80860     `
+/118            0           0     0     644     107588    `
+/137            0           0     0     644     75620     `
+/157            0           0     0     644     71556     `
+/178            0           0     0     644     114352    `
+/200            0           0     0     644     80440     `
+/223            0           0     0     644     126620    `
diff -Naur '--exclude=certs' linux-5.4.12/make_3ds.sh linux-3ds/make_3ds.sh
--- linux-5.4.12/make_3ds.sh	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/make_3ds.sh	2020-01-17 09:20:05.820837078 -0300
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+#cp arch/arm/configs/nintendo3ds_defconfig .config
+make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j6
+make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- nintendo3ds_ctr.dtb
+echo "Output file: ./arch/arm/boot/zImage"
+echo "Output DTB: ./arch/arm/boot/dts/nintendo3ds_ctr.dtb"
diff -Naur '--exclude=certs' linux-5.4.12/scripts/dtc/include-prefixes/arm/nintendo3ds_ctr.dts linux-3ds/scripts/dtc/include-prefixes/arm/nintendo3ds_ctr.dts
--- linux-5.4.12/scripts/dtc/include-prefixes/arm/nintendo3ds_ctr.dts	1969-12-31 21:00:00.000000000 -0300
+++ linux-3ds/scripts/dtc/include-prefixes/arm/nintendo3ds_ctr.dts	2020-01-31 12:43:27.014837667 -0300
@@ -0,0 +1,246 @@
+/dts-v1/;
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	model = "Nintendo 3DS (CTR)";
+	compatible = "nintendo3ds,ctr";
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&gic>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		enable-method = "nintendo3ds,smp";
+
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,arm11mpcore";
+			reg = <0>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,arm11mpcore";
+			reg = <1>;
+		};
+	};
+
+	chosen {
+		/* No FB: bootargs = "earlyprintk keep_bootcon fbcon=rotate:1 init=/init"; */
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		bootargs = "nr_cpus=2 keep_bootcon fbcon=rotate:1 root=/dev/ram0 init=init console=tty0";
+
+		display: framebuffer@18000000 {
+			compatible = "simple-framebuffer";
+			reg = <0x18000000 (400*240*3)>;
+			width = <240>;
+			height = <400>;
+			stride = <(240*3)>;
+			format = "r8g8b8";
+		};
+
+		fcram: memory@20000000 {
+			device_type = "memory";
+			reg = <0x20000000 0x08000000>;
+		};
+	};
+
+	soc {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		compatible = "simple-bus";
+
+		interrupt-parent = <&gic>;
+
+		simplehid: input@10146000 {
+			compatible = "nintendo3ds,nintendo3ds-input";
+			reg = <0x10146000 0x1000>;
+		};
+
+		backlight: backlight@10202000 {
+			compatible = "nintendo3ds,nintendo3ds-backlight";
+			reg = <0x10202000 0x4000>;
+			mcu = <&mcu>;
+		};
+
+		pxi: pxi@10163000 {
+			compatible = "nintendo3ds,nintendo3ds-pxi";
+			interrupts =
+				<GIC_SPI 0x30 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x32 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x33 IRQ_TYPE_EDGE_RISING>;
+			reg = <0x10163000 0x1000>;
+
+			mmc: mmc {
+				compatible = "nintendo3ds,nintendo3ds-mmc";
+			};
+
+			rng: rng {
+				compatible = "nintendo3ds,nintendo3ds-rng";
+			};
+		};
+
+		i2c1: i2c@10161000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10161000 0x1000>;
+		};
+
+		i2c2: i2c@10144000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10144000 0x1000>;
+
+			mcu: mcu@4a {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				compatible = "nintendo3ds,nintendo3ds-mcu";
+				reg = <0x4A>;
+
+				mcu-hid {
+					interrupt-parent = <&gic>;
+
+					compatible = "nintendo3ds,nintendo3ds-mcuhid";
+					interrupts = <GIC_SPI 0x51 IRQ_TYPE_EDGE_RISING>;
+				};
+
+				charger {
+					compatible = "nintendo3ds,nintendo3ds-charger";
+				};
+
+				reset {
+					compatible = "nintendo3ds,nintendo3ds-reset";
+				};
+
+				leds {
+					compatible = "nintendo3ds,nintendo3ds-leds";
+				};
+
+				rtc {
+					compatible = "nintendo3ds,nintendo3ds-rtc";
+				};
+
+			};
+		};
+
+		i2c3: i2c@10148000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-i2c";
+			reg = <0x10148000 0x1000>;
+		};
+
+		spi0: spi@10160800 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10160800 0x20>;
+
+			flash: nvram@1 {
+				compatible = "jedec,spi-nor";
+				reg = <1>;
+
+				spi-max-frequency = <256000>;
+			};
+		};
+
+		spi1: spi@10142800 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10142800 0x20>;
+
+			ts: codec@0 {
+				compatible = "nintendo3ds,nintendo3ds-codec";
+				spi-max-frequency = <4000000>;
+				reg = <0>;
+
+				touchscreen-size-x = <4096>;
+				touchscreen-size-y = <4096>;
+				touchscreen-inverted-y;
+				touchscreen-swapped-x-y;
+			};
+		};
+
+		spi2: spi@10143800 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			compatible = "nintendo3ds,nintendo3ds-spi";
+			reg = <0x10143800 0x20>;
+		};
+
+		refclk: refclk134mkhz {
+			compatible = "fixed-clock";
+			#clock-cells = <0>;
+			clock-frequency = <134000000>;
+			clock-output-names = "nintendo3ds:refclk144khz";
+		};
+
+		timer: twd-timer@17E00600 {
+			compatible = "arm,arm11mp-twd-timer";
+			reg = <0x17E00600 0x20>;
+			interrupts = <GIC_PPI 13 (GIC_CPU_MASK_RAW(0xF) | IRQ_TYPE_EDGE_RISING)>;
+			clocks = <&refclk>;
+		};
+
+		watchdog: twd-watchdog@17E00620 {
+			compatible = "arm,arm11mp-twd-wdt";
+			reg = <0x17E00620 0x20>;
+			interrupts = <GIC_PPI 14 (GIC_CPU_MASK_RAW(0xF) | IRQ_TYPE_EDGE_RISING)>;
+		};
+
+		gic: interrupt-controller@17E01000 {
+			compatible = "arm,arm11mp-gic";
+			#interrupt-cells = <3>;
+			#address-cells = <1>;
+			interrupt-controller;
+			reg = <0x17E01000 0x1000>,
+			      <0x17E00100 0x100>;
+		};
+
+		scu: scu@17E00000 {
+			compatible = "arm,arm11mp-scu";
+			reg = <0x17E00000 0x100>;
+		};
+	};
+
+	amba {
+		compatible = "arm,amba-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		dma@10200000 {
+			compatible = "arm,pl330", "arm,primecell";
+			reg = <0x10200000 0x1000>;
+
+			clocks = <&refclk>;
+			clock-names = "apb_pclk";
+
+			interrupts =
+				<GIC_SPI 0x39 IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x3A IRQ_TYPE_EDGE_RISING>,
+				<GIC_SPI 0x3B IRQ_TYPE_EDGE_RISING>;
+
+			#dma-cells = <1>;
+			#dma-channels = <8>;
+			#dma-requests = <32>;
+		};
+	};
+
+};
